SCRIPT  /Users/asheqimran/.vim/plugged/vim-dirvish/autoload/dirvish.vim
Sourced 1 time
Total time:   0.001054
 Self time:   0.001054

count  total (s)   self (s)
    1              0.000017 let s:srcdir = expand('<sfile>:h:h:p')
    1              0.000006 let s:sep = exists('+shellslash') && !&shellslash ? '\' : '/'
    1              0.000005 let s:noswapfile = (2 == exists(':noswapfile')) ? 'noswapfile' : ''
    1              0.000002 let s:noau       = 'silent noautocmd keepjumps'
                            
    1              0.000006 function! s:msg_error(msg) abort
                              redraw | echohl ErrorMsg | echomsg 'dirvish:' a:msg | echohl None
                            endfunction
                            
    1              0.000003 function! s:suf() abort
                              let m = get(g:, 'dirvish_mode', 1)
                              return type(m) == type(0) && m <= 1 ? 1 : 0
                            endfunction
                            
                            " Normalize slashes for safe use of fnameescape(), isdirectory(). Vim bug #541.
    1              0.000003 function! s:sl(path) abort
                              return tr(a:path, '\', '/')
                            endfunction
                            
    1              0.000002 function! s:normalize_dir(dir) abort
                              let dir = s:sl(a:dir)
                              if !isdirectory(dir)
                                "cygwin/MSYS fallback for paths that lack a drive letter.
                                let dir = empty($SYSTEMDRIVE) ? dir : '/'.tolower($SYSTEMDRIVE[0]).(dir)
                                if !isdirectory(dir)
                                  call s:msg_error("invalid directory: '".a:dir."'")
                                  return ''
                                endif
                              endif
                              " Collapse slashes (except UNC-style \\foo\bar).
                              let dir = dir[0] . substitute(dir[1:], '/\+', '/', 'g')
                              " Always end with separator.
                              return (dir[-1:] ==# '/') ? dir : dir.'/'
                            endfunction
                            
    1              0.000002 function! s:parent_dir(dir) abort
                              let mod = isdirectory(s:sl(a:dir)) ? ':p:h:h' : ':p:h'
                              return s:normalize_dir(fnamemodify(a:dir, mod))
                            endfunction
                            
    1              0.000003 if v:version > 703
    1              0.000002 function! s:globlist(pat) abort
                              return glob(a:pat, !s:suf(), 1)
                            endfunction
    1              0.000002 else "Vim 7.3 glob() cannot handle filenames containing newlines.
                            function! s:globlist(pat) abort
                              return split(glob(a:pat, !s:suf()), "\n")
                            endfunction
                            endif
                            
    1              0.000002 function! s:list_dir(dir) abort
                              " Escape for glob().
                              let dir_esc = substitute(a:dir,'\V[','[[]','g')
                              let paths = s:globlist(dir_esc.'*')
                              "Append dot-prefixed files. glob() cannot do both in 1 pass.
                              let paths = paths + s:globlist(dir_esc.'.[^.]*')
                            
                              if get(g:, 'dirvish_relative_paths', 0)
                                  \ && a:dir != s:parent_dir(getcwd()) "avoid blank CWD
                                return map(paths, "fnamemodify(v:val, ':p:.')")
                              else
                                return map(paths, "fnamemodify(v:val, ':p')")
                              endif
                            endfunction
                            
    1              0.000002 function! s:set_args(args) abort
                              if exists('*arglistid') && arglistid() == 0
                                arglocal
                              endif
                              let normalized_argv = map(argv(), 'fnamemodify(v:val, ":p")')
                              for f in a:args
                                if -1 == index(normalized_argv, f)
                                  exe '$argadd '.fnameescape(fnamemodify(f, ':p'))
                                endif
                              endfor
                              echo 'arglist: '.argc().' files'
                            
                              " Define (again) DirvishArg syntax group.
                              exe 'source '.fnameescape(s:srcdir.'/syntax/dirvish.vim')
                            endfunction
                            
    1              0.000003 function! dirvish#shdo(paths, cmd) abort
                              " Remove empty/duplicate lines.
                              let lines = uniq(sort(filter(copy(a:paths), '-1!=match(v:val,"\\S")')))
                              let head = fnamemodify(get(lines, 0, '')[:-2], ':h')
                              let jagged = 0 != len(filter(copy(lines), 'head != fnamemodify(v:val[:-2], ":h")'))
                              if empty(lines) | call s:msg_error('Shdo: no files') | return | endif
                            
                              let dirvish_bufnr = bufnr('%')
                              let cmd = a:cmd =~# '\V{}' ? a:cmd : (empty(a:cmd)?'{}':(a:cmd.' {}')) "DWIM
                              " Paths from argv() or non-dirvish buffers may be jagged; assume CWD then.
                              let dir = !jagged && exists('b:dirvish') ? b:dirvish._dir : getcwd()
                              let tmpfile = tempname().(&sh=~?'cmd.exe'?'.bat':(&sh=~'powershell'?'.ps1':'.sh'))
                            
                              for i in range(0, len(lines)-1)
                                let f = substitute(lines[i], escape(s:sep,'\').'$', '', 'g') "trim slash
                                if !filereadable(f) && !isdirectory(f)
                                  let lines[i] = '#invalid path: '.shellescape(f)
                                  continue
                                endif
                                let f = !jagged && 2==exists(':lcd') ? fnamemodify(f, ':t') : lines[i]
                                let lines[i] = substitute(cmd, '\V{}', escape(shellescape(f),'&\'), 'g')
                              endfor
                              execute 'silent split' tmpfile '|' (2==exists(':lcd')?('lcd '.dir):'')
                              setlocal bufhidden=wipe
                              silent keepmarks keepjumps call setline(1, lines)
                              silent write
                              if executable('chmod')
                                call system('chmod u+x '.tmpfile)
                                silent edit
                              endif
                            
                              augroup dirvish_shcmd
                                autocmd! * <buffer>
                                " Refresh Dirvish after executing a shell command.
                                exe 'autocmd ShellCmdPost <buffer> nested if !v:shell_error && bufexists('.dirvish_bufnr.')'
                                  \.'|setlocal bufhidden=hide|buffer '.dirvish_bufnr.'|silent! Dirvish %'
                                  \.'|buffer '.bufnr('%').'|setlocal bufhidden=wipe|endif'
                              augroup END
                            
                              nnoremap <buffer><silent> Z! :silent write<Bar>exe '!'.(has('win32')?'':shellescape(&shell)).' %'<Bar>if !v:shell_error<Bar>close<Bar>endif<CR>
                            endfunction
                            
                            " Returns true if the buffer was modified by the user.
    1              0.000002 function! s:buf_modified() abort
                              return b:changedtick > get(b:dirvish, '_c', b:changedtick)
                            endfunction
                            
    1              0.000002 function! s:buf_init() abort
                              augroup dirvish_buflocal
                                autocmd! * <buffer>
                                autocmd BufEnter,WinEnter <buffer> call <SID>on_bufenter()
                                autocmd TextChanged,TextChangedI <buffer> if <SID>buf_modified()
                                      \&& has('conceal')|exe 'setlocal conceallevel=0'|endif
                            
                                " BufUnload is fired for :bwipeout/:bdelete/:bunload, _even_ if
                                " 'nobuflisted'. BufDelete is _not_ fired if 'nobuflisted'.
                                " NOTE: For 'nohidden' we cannot reliably handle :bdelete like this.
                                if &hidden
                                  autocmd BufUnload <buffer> call s:on_bufunload()
                                endif
                              augroup END
                            
                              setlocal buftype=nofile noswapfile
                            endfunction
                            
    1              0.000002 function! s:on_bufenter() abort
                              " Ensure w:dirvish for window splits, `:b <nr>`, etc.
                              let w:dirvish = extend(get(w:, 'dirvish', {}), b:dirvish, 'keep')
                            
                              if empty(getline(1)) && 1 == line('$')
                                Dirvish %
                              elseif 3 != &l:conceallevel && !s:buf_modified()
                                call s:win_init()
                              endif
                            endfunction
                            
    1              0.000002 function! s:save_state(d) abort
                              " Remember previous ('original') buffer.
                              let a:d.prevbuf = s:buf_isvalid(bufnr('%')) || !exists('w:dirvish')
                                    \ ? 0+bufnr('%') : w:dirvish.prevbuf
                              if !s:buf_isvalid(a:d.prevbuf)
                                "If reached via :edit/:buffer/etc. we cannot get the (former) altbuf.
                                let a:d.prevbuf = exists('b:dirvish') && s:buf_isvalid(b:dirvish.prevbuf)
                                    \ ? b:dirvish.prevbuf : bufnr('#')
                              endif
                            
                              " Remember alternate buffer.
                              let a:d.altbuf = s:buf_isvalid(bufnr('#')) || !exists('w:dirvish')
                                    \ ? 0+bufnr('#') : w:dirvish.altbuf
                              if exists('b:dirvish') && (a:d.altbuf == a:d.prevbuf || !s:buf_isvalid(a:d.altbuf))
                                let a:d.altbuf = b:dirvish.altbuf
                              endif
                            
                              " Save window-local settings.
                              let w:dirvish = extend(get(w:, 'dirvish', {}), a:d, 'force')
                              let [w:dirvish._w_wrap, w:dirvish._w_cul] = [&l:wrap, &l:cul]
                              if has('conceal') && !exists('b:dirvish')
                                let [w:dirvish._w_cocu, w:dirvish._w_cole] = [&l:concealcursor, &l:conceallevel]
                              endif
                            endfunction
                            
    1              0.000002 function! s:win_init() abort
                              let w:dirvish = extend(get(w:, 'dirvish', {}), b:dirvish, 'keep')
                              setlocal nowrap cursorline
                            
                              if has('conceal')
                                setlocal concealcursor=nvc conceallevel=3
                              endif
                            endfunction
                            
    1              0.000002 function! s:on_bufunload() abort
                              call s:restore_winlocal_settings()
                            endfunction
                            
    1              0.000002 function! s:buf_close() abort
                              let d = get(w:, 'dirvish', {})
                              if empty(d)
                                return
                              endif
                            
                              let [altbuf, prevbuf] = [get(d, 'altbuf', 0), get(d, 'prevbuf', 0)]
                              let found_alt = s:try_visit(altbuf, 1)
                              if !s:try_visit(prevbuf, 0) && !found_alt
                                  \ && (1 == bufnr('%') || (prevbuf != bufnr('%') && altbuf != bufnr('%')))
                                bdelete
                              endif
                            endfunction
                            
    1              0.000002 function! s:restore_winlocal_settings() abort
                              if !exists('w:dirvish') " can happen during VimLeave, etc.
                                return
                              endif
                              if has('conceal') && has_key(w:dirvish, '_w_cocu')
                                let [&l:cocu, &l:cole] = [w:dirvish._w_cocu, w:dirvish._w_cole]
                              endif
                            endfunction
                            
    1              0.000003 function! s:open_selected(splitcmd, bg, line1, line2) abort
                              let curbuf = bufnr('%')
                              let [curtab, curwin, wincount] = [tabpagenr(), winnr(), winnr('$')]
                              let p = (a:splitcmd ==# 'p')  " Preview-mode
                            
                              let paths = getline(a:line1, a:line2)
                              for path in paths
                                let path = s:sl(path)
                                if !isdirectory(path) && !filereadable(path)
                                  call s:msg_error("invalid (or access denied): ".path)
                                  continue
                                endif
                            
                                if p
                                  exe (winnr('$') > 1 ? 'wincmd p' : 'vsplit')
                                endif
                            
                                if isdirectory(path)
                                  exe (p || a:splitcmd ==# 'edit' ? '' : a:splitcmd.'|') 'Dirvish' fnameescape(path)
                                else
                                  exe (p ? 'edit' : a:splitcmd) fnameescape(path)
                                endif
                            
                                " Return to previous window after _each_ split, else we get lost.
                                if a:bg && (p || (a:splitcmd =~# 'sp' && winnr('$') > wincount))
                                  wincmd p
                                endif
                              endfor
                            
                              if a:bg "return to dirvish buffer
                                if a:splitcmd ==# 'tabedit'
                                  exe 'tabnext' curtab '|' curwin.'wincmd w'
                                elseif a:splitcmd ==# 'edit'
                                  execute 'silent keepalt keepjumps buffer' curbuf
                                endif
                              elseif !exists('b:dirvish') && exists('w:dirvish')
                                call s:set_altbuf(w:dirvish.prevbuf)
                              endif
                            endfunction
                            
    1              0.000002 function! s:is_valid_altbuf(bnr) abort
                              return a:bnr != bufnr('%') && bufexists(a:bnr) && empty(getbufvar(a:bnr, 'dirvish'))
                            endfunction
                            
    1              0.000002 function! s:set_altbuf(bnr) abort
                              if !s:is_valid_altbuf(a:bnr) | return | endif
                            
                              if has('patch-7.4.605') | let @# = a:bnr | return | endif
                            
                              let curbuf = bufnr('%')
                              if s:try_visit(a:bnr, 1)
                                let noau = bufloaded(curbuf) ? 'noau' : ''
                                " Return to the current buffer.
                                execute 'silent keepjumps' noau s:noswapfile 'buffer' curbuf
                              endif
                            endfunction
                            
    1              0.000002 function! s:try_visit(bnr, noau) abort
                              if s:is_valid_altbuf(a:bnr)
                                " If _previous_ buffer is _not_ loaded (because of 'nohidden'), we must
                                " allow autocmds (else no syntax highlighting; #13).
                                let noau = a:noau && bufloaded(a:bnr) ? 'noau' : ''
                                execute 'silent keepjumps' noau s:noswapfile 'buffer' a:bnr
                                return 1
                              endif
                              return 0
                            endfunction
                            
    1              0.000003 function! s:tab_win_do(tnr, cmd, bname) abort
                              exe s:noau 'tabnext' a:tnr
                              for wnr in range(1, tabpagewinnr(a:tnr, '$'))
                                if a:bname ==# bufname(winbufnr(wnr))
                                  exe s:noau wnr.'wincmd w'
                                  exe a:cmd
                                endif
                              endfor
                            endfunction
                            
                            " Performs `cmd` in all windows showing `bname`.
    1              0.000002 function! s:bufwin_do(cmd, bname) abort
                              let [curtab, curwin, curwinalt] = [tabpagenr(), winnr(), winnr('#')]
                              for tnr in range(1, tabpagenr('$'))
                                let [origwin, origwinalt] = [tabpagewinnr(tnr), tabpagewinnr(tnr, '#')]
                                for bnr in tabpagebuflist(tnr)
                                  if a:bname ==# bufname(bnr) " tab has at least 1 matching window
                                    call s:tab_win_do(tnr, a:cmd, a:bname)
                                    exe s:noau origwinalt.'wincmd w|' s:noau origwin.'wincmd w'
                                    break
                                  endif
                                endfor
                              endfor
                              exe s:noau 'tabnext '.curtab
                              exe s:noau curwinalt.'wincmd w|' s:noau curwin.'wincmd w'
                            endfunction
                            
    1              0.000003 function! s:buf_render(dir, lastpath) abort
                              let bname = bufname('%')
                              let isnew = empty(getline(1))
                            
                              if !isdirectory(s:sl(bname))
                                echoerr 'dirvish: fatal: buffer name is not a directory:' bufname('%')
                                return
                              endif
                            
                              if !isnew
                                call s:bufwin_do('let w:dirvish["_view"] = winsaveview()', bname)
                              endif
                            
                              if v:version > 704 || v:version == 704 && has("patch73")
                                setlocal undolevels=-1
                              endif
                              silent keepmarks keepjumps %delete _
                              silent keepmarks keepjumps call setline(1, s:list_dir(a:dir))
                              if type("") == type(get(g:, 'dirvish_mode'))  " Apply user's filter.
                                execute get(g:, 'dirvish_mode')
                              endif
                              if v:version > 704 || v:version == 704 && has("patch73")
                                setlocal undolevels<
                              endif
                            
                              if !isnew
                                call s:bufwin_do('call winrestview(w:dirvish["_view"])', bname)
                              endif
                            
                              if !empty(a:lastpath)
                                let pat = get(g:, 'dirvish_relative_paths', 0) ? fnamemodify(a:lastpath, ':p:.') : a:lastpath
                                let pat = empty(pat) ? a:lastpath : pat  " no longer in CWD
                                call search('\V\^'.escape(pat, '\').'\$', 'cw')
                              endif
                              " Place cursor on the tail (last path segment).
                              call search('\'.s:sep.'\zs[^\'.s:sep.']\+\'.s:sep.'\?$', 'c', line('.'))
                            endfunction
                            
    1              0.000002 function! s:open_dir(d, reload) abort
                              let d = a:d
                              let dirname_without_sep = substitute(d._dir, '[\\/]\+$', '', 'g')
                            
                              " Vim tends to 'simplify' buffer names. Examples (gvim 7.4.618):
                              "     ~\foo\, ~\foo, foo\, foo
                              " Try to find an existing buffer before creating a new one.
                              let bnr = -1
                              for pat in ['', ':~:.', ':~']
                                let bnr = bufnr('^'.fnamemodify(d._dir, pat).'$')
                                if -1 != bnr
                                  break
                                endif
                              endfor
                            
                              if -1 == bnr
                                execute 'silent' s:noswapfile 'edit' fnameescape(d._dir)
                              else
                                execute 'silent' s:noswapfile 'buffer' bnr
                              endif
                            
                              " Use :file to force a normalized path.
                              " - Avoids ".././..", ".", "./", etc. (breaks %:p, not updated on :cd).
                              " - Avoids [Scratch] in some cases (":e ~/" on Windows).
                              if s:sl(bufname('%')) !=# d._dir
                                execute 'silent '.s:noswapfile.' file ' . fnameescape(d._dir)
                              endif
                            
                              if !isdirectory(bufname('%'))  " sanity check
                                throw 'invalid directory: '.bufname('%')
                              endif
                            
                              if &buflisted && bufnr('$') > 1
                                setlocal nobuflisted
                              endif
                            
                              call s:set_altbuf(d.prevbuf) "in case of :bd, :read#, etc.
                            
                              let b:dirvish = exists('b:dirvish') ? extend(b:dirvish, d, 'force') : d
                            
                              call s:buf_init()
                              call s:win_init()
                              if a:reload || s:should_reload()
                                call s:buf_render(b:dirvish._dir, get(b:dirvish, 'lastpath', ''))
                                " Set up Dirvish before any other `FileType dirvish` handler.
                                exe 'source '.fnameescape(s:srcdir.'/ftplugin/dirvish.vim')
                                setlocal filetype=dirvish
                                let b:dirvish._c = b:changedtick
                              endif
                            endfunction
                            
    1              0.000002 function! s:should_reload() abort
                              if line('$') < 1000 || '' ==# glob(getline('$'),1)
                                return !s:buf_modified() || (empty(getline(1)) && 1 == line('$'))
                              endif
                              redraw | echo 'dirvish: showing cached listing ("R" to reload)'
                              return 0
                            endfunction
                            
    1              0.000002 function! s:buf_isvalid(bnr) abort
                              return bufexists(a:bnr) && !isdirectory(s:sl(bufname(a:bnr)))
                            endfunction
                            
    1              0.000002 function! dirvish#open(...) range abort
                              if &autochdir
                                call s:msg_error("'autochdir' is not supported")
                                return
                              endif
                              if !&hidden && &modified
                                  \ && (!exists("*win_findbuf") || len(win_findbuf(winbufnr(0))) == 1)
                                call s:msg_error("E37: No write since last change")
                                return
                              endif
                            
                              if a:0 > 1
                                call s:open_selected(a:1, a:2, a:firstline, a:lastline)
                                return
                              endif
                            
                              let d = {}
                              let from_path = fnamemodify(bufname('%'), ':p')
                              let to_path   = fnamemodify(s:sl(a:1), ':p')
                              "                                       ^resolves to CWD if a:1 is empty
                            
                              let d._dir = filereadable(to_path) ? fnamemodify(to_path, ':p:h') : to_path
                              let d._dir = s:normalize_dir(d._dir)
                              if '' ==# d._dir " s:normalize_dir() already showed error.
                                return
                              endif
                            
                              let reloading = exists('b:dirvish') && d._dir ==# b:dirvish._dir
                            
                              if reloading
                                let d.lastpath = ''         " Do not place cursor when reloading.
                              elseif d._dir ==# s:parent_dir(from_path)
                                let d.lastpath = from_path  " Save lastpath when navigating _up_.
                              endif
                            
                              call s:save_state(d)
                              call s:open_dir(d, reloading)
                            endfunction
                            
    1              0.000069 nnoremap <silent> <Plug>(dirvish_quit) :<C-U>call <SID>buf_close()<CR>
    1              0.000025 nnoremap <silent> <Plug>(dirvish_arg) :<C-U>call <SID>set_args([getline('.')])<CR>
    1              0.000038 xnoremap <silent> <Plug>(dirvish_arg) :<C-U>call <SID>set_args(getline("'<", "'>"))<CR>

SCRIPT  /Users/asheqimran/.vim/plugged/vim-dirvish/ftplugin/dirvish.vim
Sourced 4 times
Total time:   0.000638
 Self time:   0.000638

count  total (s)   self (s)
    4              0.000024 if exists("b:did_ftplugin")
    3              0.000006   finish
                            endif
    1              0.000003 let b:did_ftplugin = 1
                            
    1              0.000003 let s:nowait = (v:version > 703 ? '<nowait>' : '')
                            
    1              0.000050 if !hasmapto('<Plug>(dirvish_quit)', 'n')
    1              0.000018   execute 'nmap '.s:nowait.'<buffer> q <Plug>(dirvish_quit)'
    1              0.000001 endif
    1              0.000031 if !hasmapto('<Plug>(dirvish_arg)', 'n')
    1              0.000016   execute 'nmap '.s:nowait.'<buffer> x <Plug>(dirvish_arg)'
    1              0.000015   execute 'xmap '.s:nowait.'<buffer> x <Plug>(dirvish_arg)'
    1              0.000001 endif
                            
    1              0.000015 nnoremap <buffer><silent> <Plug>(dirvish_up) :<C-U>exe "Dirvish %:h".repeat(":h",v:count1)<CR>
    1              0.000014 nnoremap <buffer><silent> <Plug>(dirvish_split_up) :<C-U>exe 'split +Dirvish\ %:h'.repeat(':h',v:count1)<CR>
    1              0.000014 nnoremap <buffer><silent> <Plug>(dirvish_vsplit_up) :<C-U>exe 'vsplit +Dirvish\ %:h'.repeat(':h',v:count1)<CR>
    1              0.000030 if !hasmapto('<Plug>(dirvish_up)', 'n')
    1              0.000015   execute 'nmap '.s:nowait.'<buffer> - <Plug>(dirvish_up)'
    1              0.000001 endif
                            
    1              0.000020 execute 'nnoremap '.s:nowait.'<buffer><silent> i    :<C-U>.call dirvish#open("edit", 0)<CR>'
    1              0.000015 execute 'nnoremap '.s:nowait.'<buffer><silent> <CR> :<C-U>.call dirvish#open("edit", 0)<CR>'
    1              0.000015 execute 'nnoremap '.s:nowait.'<buffer><silent> a    :<C-U>.call dirvish#open("vsplit", 1)<CR>'
    1              0.000014 execute 'nnoremap '.s:nowait.'<buffer><silent> o    :<C-U>.call dirvish#open("split", 1)<CR>'
    1              0.000014 execute 'nnoremap '.s:nowait.'<buffer><silent> p    :<C-U>.call dirvish#open("p", 1)<CR>'
    1              0.000016 execute 'nnoremap '.s:nowait.'<buffer><silent> <2-LeftMouse> :<C-U>.call dirvish#open("edit", 0)<CR>'
    1              0.000017 execute 'nnoremap '.s:nowait.'<buffer><silent> dax  :<C-U>arglocal<Bar>silent! argdelete *<Bar>echo "arglist: cleared"<Bar>Dirvish %<CR>'
    1              0.000014 execute 'nnoremap '.s:nowait.'<buffer><silent> <C-n> <C-\><C-n>j:call feedkeys("p")<CR>'
    1              0.000014 execute 'nnoremap '.s:nowait.'<buffer><silent> <C-p> <C-\><C-n>k:call feedkeys("p")<CR>'
                            
    1              0.000015 execute 'xnoremap '.s:nowait.'<buffer><silent> I    :call dirvish#open("edit", 0)<CR>'
    1              0.000015 execute 'xnoremap '.s:nowait.'<buffer><silent> <CR> :call dirvish#open("edit", 0)<CR>'
    1              0.000014 execute 'xnoremap '.s:nowait.'<buffer><silent> A    :call dirvish#open("vsplit", 1)<CR>'
    1              0.000014 execute 'xnoremap '.s:nowait.'<buffer><silent> O    :call dirvish#open("split", 1)<CR>'
    1              0.000013 execute 'xnoremap '.s:nowait.'<buffer><silent> P    :call dirvish#open("p", 1)<CR>'
                            
    1              0.000014 nnoremap <buffer><silent> R :<C-U><C-R>=v:count ? ':let g:dirvish_mode='.v:count.'<Bar>' : ''<CR>Dirvish %<CR>
    1              0.000011 nnoremap <buffer><silent>   g?    :help dirvish-mappings<CR>
                            
    1              0.000014 execute 'nnoremap '.s:nowait.'<buffer> X :Shdo  {}<Left><Left><Left>'
    1              0.000015 execute 'xnoremap '.s:nowait.'<buffer> X :Shdo  {}<Left><Left><Left>'
    1              0.000014 execute 'nnoremap '.s:nowait.'<buffer> !X :Shdo!  {}<Left><Left><Left>'
    1              0.000013 execute 'nnoremap '.s:nowait.'<buffer> !. :Shdo<CR>"_dd:write<CR>'
                            
                            " Buffer-local / and ? mappings to skip the concealed path fragment.
    1              0.000011 nnoremap <buffer> / /\ze[^\/]*[\/]\=$<Home>
    1              0.000017 nnoremap <buffer> ? ?\ze[^\/]*[\/]\=$<Home>

SCRIPT  /Users/asheqimran/.vim/after/ftplugin/dirvish.vim
Sourced 2 times
Total time:   0.000077
 Self time:   0.000077

count  total (s)   self (s)
    2              0.000013 setlocal nospell
    2              0.000041 nmap <buffer> <BS> <Plug>(dirvish_up)

SCRIPT  /Users/asheqimran/.vim/plugged/vim-dirvish/syntax/dirvish.vim
Sourced 2 times
Total time:   0.000267
 Self time:   0.000267

count  total (s)   self (s)
    2              0.000013 if 'dirvish' !=# get(b:, 'current_syntax', 'dirvish')
                              finish
                            endif
                            
    2              0.000008 let s:sep = exists('+shellslash') && !&shellslash ? '\' : '/'
    2              0.000004 let s:escape = 'substitute(escape(v:val, ".$~"), "*", ".*", "g")'
                            
                            " Define (again). Other windows may need the old definitions ...
    2              0.000012 let s:pat = join(map(argv(), 'escape(fnamemodify(v:val[-1:]==#s:sep?v:val[:-2]:v:val, ":t"), "*.^$~\\")'), '\|')
    2              0.000030 exe 'syntax match DirvishArg /\'.s:sep.'\@<=\%\('.s:pat.'\)\'.s:sep.'\?$/'
                            
    2              0.000005 if exists('b:current_syntax')
                              finish
                            endif
                            
    2              0.000038 exe 'syntax match DirvishPathHead =\v.*\'.s:sep.'\ze[^\'.s:sep.']+\'.s:sep.'?$= conceal'
    2              0.000013 exe 'syntax match DirvishPathTail =\v[^\'.s:sep.']+\'.s:sep.'$='
    2              0.000097 exe 'syntax match DirvishSuffix   =[^\'.s:sep.']*\%('.join(map(split(&suffixes, ','), s:escape), '\|') . '\)$='
                            
    2              0.000012 let b:current_syntax = "dirvish"

SCRIPT  /usr/local/Cellar/neovim/0.2.2_1/share/nvim/runtime/ftplugin/vim.vim
Sourced 1 time
Total time:   0.000361
 Self time:   0.000361

count  total (s)   self (s)
                            " Vim filetype plugin
                            " Language:	Vim
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2014 Sep 07
                            
                            " Only do this when not done yet for this buffer
    1              0.000005 if exists("b:did_ftplugin")
                              finish
                            endif
                            
                            " Don't load another plugin for this buffer
    1              0.000002 let b:did_ftplugin = 1
                            
    1              0.000004 let s:cpo_save = &cpo
    1              0.000007 set cpo-=C
                            
    1              0.000005 let b:undo_ftplugin = "setl fo< isk< com< tw< commentstring< keywordprg<"
                            	\ . "| unlet! b:match_ignorecase b:match_words b:match_skip"
                            
                            " Set 'formatoptions' to break comment lines but not other lines,
                            " and insert the comment leader when hitting <CR> or using "o".
    1              0.000007 setlocal fo-=t fo+=croql
                            
                            " To allow tag lookup via CTRL-] for autoload functions, '#' must be a
                            " keyword character.  E.g., for netrw#Nread().
    1              0.000038 setlocal isk+=#
                            
                            " Set 'comments' to format dashed lists in comments
    1              0.000005 setlocal com=sO:\"\ -,mO:\"\ \ ,eO:\"\",:\"
                            
                            " Format comments to be up to 78 characters long
    1              0.000002 if &tw == 0
                              setlocal tw=78
                            endif
                            
                            " Comments start with a double quote
    1              0.000003 setlocal commentstring=\"%s
                            
                            " Prefer Vim help instead of manpages.
    1              0.000002 setlocal keywordprg=:help
                            
                            " Move around functions.
    1              0.000060 nnoremap <silent><buffer> [[ m':call search('^\s*fu\%[nction]\>', "bW")<CR>
    1              0.000016 vnoremap <silent><buffer> [[ m':<C-U>exe "normal! gv"<Bar>call search('^\s*fu\%[nction]\>', "bW")<CR>
    1              0.000012 nnoremap <silent><buffer> ]] m':call search('^\s*fu\%[nction]\>', "W")<CR>
    1              0.000013 vnoremap <silent><buffer> ]] m':<C-U>exe "normal! gv"<Bar>call search('^\s*fu\%[nction]\>', "W")<CR>
    1              0.000012 nnoremap <silent><buffer> [] m':call search('^\s*endf*\%[unction]\>', "bW")<CR>
    1              0.000013 vnoremap <silent><buffer> [] m':<C-U>exe "normal! gv"<Bar>call search('^\s*endf*\%[unction]\>', "bW")<CR>
    1              0.000012 nnoremap <silent><buffer> ][ m':call search('^\s*endf*\%[unction]\>', "W")<CR>
    1              0.000013 vnoremap <silent><buffer> ][ m':<C-U>exe "normal! gv"<Bar>call search('^\s*endf*\%[unction]\>', "W")<CR>
                            
                            " Move around comments
    1              0.000012 nnoremap <silent><buffer> ]" :call search('^\(\s*".*\n\)\@<!\(\s*"\)', "W")<CR>
    1              0.000013 vnoremap <silent><buffer> ]" :<C-U>exe "normal! gv"<Bar>call search('^\(\s*".*\n\)\@<!\(\s*"\)', "W")<CR>
    1              0.000012 nnoremap <silent><buffer> [" :call search('\%(^\s*".*\n\)\%(^\s*"\)\@!', "bW")<CR>
    1              0.000017 vnoremap <silent><buffer> [" :<C-U>exe "normal! gv"<Bar>call search('\%(^\s*".*\n\)\%(^\s*"\)\@!', "bW")<CR>
                            
                            " Let the matchit plugin know what items can be matched.
    1              0.000003 if exists("loaded_matchit")
    1              0.000002   let b:match_ignorecase = 0
    1              0.000010   let b:match_words =
                            	\ '\<fu\%[nction]\>:\<retu\%[rn]\>:\<endf\%[unction]\>,' .
                             	\ '\<\(wh\%[ile]\|for\)\>:\<brea\%[k]\>:\<con\%[tinue]\>:\<end\(w\%[hile]\|fo\%[r]\)\>,' .
                            	\ '\<if\>:\<el\%[seif]\>:\<en\%[dif]\>,' .
                            	\ '\<try\>:\<cat\%[ch]\>:\<fina\%[lly]\>:\<endt\%[ry]\>,' .
                            	\ '\<aug\%[roup]\s\+\%(END\>\)\@!\S:\<aug\%[roup]\s\+END\>,' .
                            	\ '(:)'
                              " Ignore syntax region commands and settings, any 'en*' would clobber
                              " if-endif.
                              " - set spl=de,en
                              " - au! FileType javascript syntax region foldBraces start=/{/ end=/}/ â€¦
    1              0.000003   let b:match_skip = 'synIDattr(synID(line("."),col("."),1),"name")
                                    \ =~? "comment\\|string\\|vimSynReg\\|vimSet"'
    1              0.000001 endif
                            
    1              0.000005 let &cpo = s:cpo_save
    1              0.000002 unlet s:cpo_save
                            
                            " removed this, because 'cpoptions' is a global option.
                            " setlocal cpo+=M		" makes \%( match \)

SCRIPT  /Users/asheqimran/.vim/plugged/vim-textobj-function/after/ftplugin/vim/textobj-function.vim
Sourced 1 time
Total time:   0.000052
 Self time:   0.000052

count  total (s)   self (s)
                            " Vim additional ftplugin: vim/textobj-function
                            " Version: 0.4.0
                            " Copyright (C) 2007-2014 Kana Natsuno <http://whileimautomaton.net/>
                            " License: MIT license  {{{
                            "     Permission is hereby granted, free of charge, to any person obtaining
                            "     a copy of this software and associated documentation files (the
                            "     "Software"), to deal in the Software without restriction, including
                            "     without limitation the rights to use, copy, modify, merge, publish,
                            "     distribute, sublicense, and/or sell copies of the Software, and to
                            "     permit persons to whom the Software is furnished to do so, subject to
                            "     the following conditions:
                            "
                            "     The above copyright notice and this permission notice shall be included
                            "     in all copies or substantial portions of the Software.
                            "
                            "     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                            "     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            "     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
                            "     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
                            "     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
                            "     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
                            "     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            " }}}
                            
                            
                            
                            
    1              0.000008 let b:textobj_function_select = function('textobj#function#vim#select')
                            
                            
                            
                            
    1              0.000003 if exists('b:undo_ftplugin')
    1              0.000003   let b:undo_ftplugin .= '|'
    1              0.000001 else
                              let b:undo_ftplugin = ''
                            endif
    1              0.000002 let b:undo_ftplugin .= 'unlet b:textobj_function_select'
                            
                            " __END__
                            " vim: foldmethod=marker

SCRIPT  /usr/local/Cellar/neovim/0.2.2_1/share/nvim/runtime/indent/vim.vim
Sourced 1 time
Total time:   0.000192
 Self time:   0.000192

count  total (s)   self (s)
                            " Vim indent file
                            " Language:	Vim script
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2016 Jun 27
                            
                            " Only load this indent file when no other was loaded.
    1              0.000004 if exists("b:did_indent")
                              finish
                            endif
    1              0.000002 let b:did_indent = 1
                            
    1              0.000004 setlocal indentexpr=GetVimIndent()
    1              0.000003 setlocal indentkeys+==end,=else,=cat,=fina,=END,0\\
                            
    1              0.000002 let b:undo_indent = "setl indentkeys< indentexpr<"
                            
                            " Only define the function once.
    1              0.000003 if exists("*GetVimIndent")
                              finish
                            endif
    1              0.000003 let s:keepcpo= &cpo
    1              0.000003 set cpo&vim
                            
    1              0.000002 function GetVimIndent()
                              let ignorecase_save = &ignorecase
                              try
                                let &ignorecase = 0
                                return GetVimIndentIntern()
                              finally
                                let &ignorecase = ignorecase_save
                              endtry
                            endfunc
                            
    1              0.000002 function GetVimIndentIntern()
                              " Find a non-blank line above the current line.
                              let lnum = prevnonblank(v:lnum - 1)
                            
                              " If the current line doesn't start with '\' and below a line that starts
                              " with '\', use the indent of the line above it.
                              let cur_text = getline(v:lnum)
                              if cur_text !~ '^\s*\\'
                                while lnum > 0 && getline(lnum) =~ '^\s*\\'
                                  let lnum = lnum - 1
                                endwhile
                              endif
                            
                              " At the start of the file use zero indent.
                              if lnum == 0
                                return 0
                              endif
                              let prev_text = getline(lnum)
                            
                              " Add a 'shiftwidth' after :if, :while, :try, :catch, :finally, :function
                              " and :else.  Add it three times for a line that starts with '\' after
                              " a line that doesn't (or g:vim_indent_cont if it exists).
                              let ind = indent(lnum)
                              if cur_text =~ '^\s*\\' && v:lnum > 1 && prev_text !~ '^\s*\\'
                                if exists("g:vim_indent_cont")
                                  let ind = ind + g:vim_indent_cont
                                else
                                  let ind = ind + shiftwidth() * 3
                                endif
                              elseif prev_text =~ '^\s*aug\%[roup]\s\+' && prev_text !~ '^\s*aug\%[roup]\s\+[eE][nN][dD]\>'
                                let ind = ind + shiftwidth()
                              else
                                " A line starting with :au does not increment/decrement indent.
                                if prev_text !~ '^\s*au\%[tocmd]'
                                  let i = match(prev_text, '\(^\||\)\s*\(if\|wh\%[ile]\|for\|try\|cat\%[ch]\|fina\%[lly]\|fu\%[nction]\|el\%[seif]\)\>')
                                  if i >= 0
                            	let ind += shiftwidth()
                            	if strpart(prev_text, i, 1) == '|' && has('syntax_items')
                            	      \ && synIDattr(synID(lnum, i, 1), "name") =~ '\(Comment\|String\)$'
                            	  let ind -= shiftwidth()
                            	endif
                                  endif
                                endif
                              endif
                            
                              " If the previous line contains an "end" after a pipe, but not in an ":au"
                              " command.  And not when there is a backslash before the pipe.
                              " And when syntax HL is enabled avoid a match inside a string.
                              let i = match(prev_text, '[^\\]|\s*\(ene\@!\)')
                              if i > 0 && prev_text !~ '^\s*au\%[tocmd]'
                                if !has('syntax_items') || synIDattr(synID(lnum, i + 2, 1), "name") !~ '\(Comment\|String\)$'
                                  let ind = ind - shiftwidth()
                                endif
                              endif
                            
                            
                              " Subtract a 'shiftwidth' on a :endif, :endwhile, :catch, :finally, :endtry,
                              " :endfun, :else and :augroup END.
                              if cur_text =~ '^\s*\(ene\@!\|cat\|fina\|el\|aug\%[roup]\s\+[eE][nN][dD]\)'
                                let ind = ind - shiftwidth()
                              endif
                            
                              return ind
                            endfunction
                            
    1              0.000005 let &cpo = s:keepcpo
    1              0.000001 unlet s:keepcpo
                            
                            " vim:sw=2

SCRIPT  /usr/local/Cellar/neovim/0.2.2_1/share/nvim/runtime/syntax/vim.vim
Sourced 1 time
Total time:   0.005258
 Self time:   0.005258

count  total (s)   self (s)
                            " Vim syntax file
                            
                            " #############################################################################
                            " #############################################################################
                            " Note: Be careful when merging the upstream version of this file.
                            "       Much of this is generated by scripts/genvimvim.lua
                            "       (installs to $VIMRUNTIME/syntax/vim/generated.vim)
                            " #############################################################################
                            " #############################################################################
                            
                            " Quit when a syntax file was already loaded {{{2
    1              0.000004 if exists("b:current_syntax")
                              finish
                            endif
    1              0.000003 let s:keepcpo= &cpo
    1              0.000003 set cpo&vim
                            
                            " vimTodo: contains common special-notices for comments {{{2
                            " Use the vimCommentGroup cluster to add your own.
    1              0.000015 syn keyword vimTodo contained	COMBAK	FIXME	TODO	XXX
    1              0.000005 syn cluster vimCommentGroup	contains=vimTodo,@Spell
                            
                            " Special and plugin vim commands {{{2
    1              0.000008 syn match   vimCommand contained	"\<z[-+^.=]\=\>"
    1              0.000007 syn keyword vimOnlyCommand contained	fix[del] op[en] sh[ell] P[rint]
    1              0.000006 syn keyword vimStdPlugin contained	DiffOrig Man N[ext] S TOhtml XMLent XMLns
                            
                            " Vim-specific options {{{2
    1              0.000015 syn keyword vimOnlyOption contained	biosk bioskey cp compatible consk conskey cm cryptmethod edcompatible guipty key macatsui mzq mzquantum osfiletype oft renderoptions rop st shelltype sn shortname tenc termencoding ta textauto tx textmode tf ttyfast ttym ttymouse tbi ttybuiltin wiv weirdinvert
                            
                            " Turn-off setting variants
    1              0.000007 syn keyword vimOnlyOption contained	nobiosk nobioskey noconsk noconskey nocp nocompatible noguipty nomacatsui nosn noshortname nota notextauto notx notextmode notf nottyfast notbi nottybuiltin nowiv noweirdinvert
                            
                            " Invertible setting variants
    1              0.000007 syn keyword vimOnlyOption contained	invbiosk invbioskey invconsk invconskey invcp invcompatible invguipty invmacatsui invsn invshortname invta invtextauto invtx invtextmode invtf invttyfast invtbi invttybuiltin invwiv invweirdinvert
                            " termcap codes (which can also be set) {{{2
    1              0.000066 syn keyword vimTermOption contained	t_8b t_AB t_al t_bc t_ce t_cl t_Co t_Cs t_CV t_db t_DL t_F1 t_F2 t_F3 t_F4 t_F5 t_F6 t_F7 t_F8 t_F9 t_fs t_IE t_IS t_k1 t_K1 t_k2 t_k3 t_K3 t_k4 t_K4 t_k5 t_K5 t_k6 t_K6 t_k7 t_K7 t_k8 t_K8 t_k9 t_K9 t_KA t_kb t_kB t_KB t_KC t_kd t_kD t_KD t_ke t_KE t_KF t_KG t_kh t_KH t_kI t_KI t_KJ t_KK t_kl t_KL t_kN t_kP t_kr t_ks t_ku t_le t_mb t_md t_me t_mr t_ms t_nd t_op t_RB t_RI t_RV t_Sb t_se t_Sf t_SI t_so t_sr t_SR t_te t_ti t_ts t_u7 t_ue t_us t_ut t_vb t_ve t_vi t_vs t_WP t_WS t_xn t_xs t_ZH t_ZR
    1              0.000003 syn keyword vimTermOption contained	t_8f t_AF t_AL t_cd t_Ce t_cm t_cs t_CS t_da t_dl t_EI
    1              0.000003 syn match   vimTermOption contained	"t_%1"
    1              0.000002 syn match   vimTermOption contained	"t_#2"
    1              0.000002 syn match   vimTermOption contained	"t_#4"
    1              0.000002 syn match   vimTermOption contained	"t_@7"
    1              0.000002 syn match   vimTermOption contained	"t_*7"
    1              0.000002 syn match   vimTermOption contained	"t_&8"
    1              0.000002 syn match   vimTermOption contained	"t_%i"
    1              0.000002 syn match   vimTermOption contained	"t_k;"
                            
                            " unsupported settings: these are supported by vi but don't do anything in vim {{{2
    1              0.000005 syn keyword vimErrSetting contained	hardtabs ht w1200 w300 w9600 
                            "}}}2
    1              0.000001 syn case ignore
                            " Highlight commonly used Groupnames {{{2
    1              0.000015 syn keyword vimGroup contained	Comment Constant String Character Number Boolean Float Identifier Function Statement Conditional Repeat Label Operator Keyword Exception PreProc Include Define Macro PreCondit Type StorageClass Structure Typedef Special SpecialChar Tag Delimiter SpecialComment Debug Underlined Ignore Error Todo 
                            
                            " Default highlighting groups {{{2
    1              0.000022 syn keyword vimHLGroup contained	ColorColumn Cursor CursorColumn CursorIM CursorLine CursorLineNr DiffAdd DiffChange DiffDelete DiffText Directory EndOfBuffer ErrorMsg FoldColumn Folded IncSearch LineNr MatchParen Menu ModeMsg MoreMsg NonText Normal Pmenu PmenuSbar PmenuSel PmenuThumb Question Scrollbar Search SignColumn SpecialKey SpellBad SpellCap SpellLocal SpellRare StatusLine StatusLineNC TabLine TabLineFill TabLineSel Title Tooltip VertSplit Visual WarningMsg WildMenu 
    1              0.000003 syn match vimHLGroup contained	"Conceal"
    1              0.000005 syn keyword vimOnlyHLGroup contained	VisualNOS
    1              0.000006 syn keyword nvimHLGroup contained	Substitute TermCursor TermCursorNC QuickFixLine
                            "}}}2
    1              0.000001 syn case match
                            " Special Vim Highlighting (not automatic) {{{1
                            
                            " Set up folding commands
    1              0.000006 if exists("g:vimsyn_folding") && g:vimsyn_folding =~# '[aflmpPrt]'
                             if g:vimsyn_folding =~# 'a' 
                              com! -nargs=* VimFolda <args> fold 
                             else 
                              com! -nargs=* VimFolda <args> 
                             endif
                             if g:vimsyn_folding =~# 'f' 
                              com! -nargs=* VimFoldf <args> fold 
                             else 
                              com! -nargs=* VimFoldf <args> 
                             endif
                             if g:vimsyn_folding =~# 'l' 
                              com! -nargs=* VimFoldl <args> fold 
                             else 
                              com! -nargs=* VimFoldl <args> 
                             endif
                             if g:vimsyn_folding =~# 'm' 
                              com! -nargs=* VimFoldm <args> fold 
                             else 
                              com! -nargs=* VimFoldm <args> 
                             endif
                             if g:vimsyn_folding =~# 'p' 
                              com! -nargs=* VimFoldp <args> fold 
                             else 
                              com! -nargs=* VimFoldp <args> 
                             endif
                             if g:vimsyn_folding =~# 'P' 
                              com! -nargs=* VimFoldP <args> fold 
                             else 
                              com! -nargs=* VimFoldP <args> 
                             endif
                             if g:vimsyn_folding =~# 'r' 
                              com! -nargs=* VimFoldr <args> fold 
                             else 
                              com! -nargs=* VimFoldr <args> 
                             endif
                             if g:vimsyn_folding =~# 't' 
                              com! -nargs=* VimFoldt <args> fold 
                             else 
                              com! -nargs=* VimFoldt <args> 
                             endif
                            else
    1              0.000006  com! -nargs=*	VimFolda	<args>
    1              0.000003  com! -nargs=*	VimFoldf	<args>
    1              0.000003  com! -nargs=*	VimFoldl	<args>
    1              0.000003  com! -nargs=*	VimFoldm	<args>
    1              0.000003  com! -nargs=*	VimFoldp	<args>
    1              0.000003  com! -nargs=*	VimFoldP	<args>
    1              0.000003  com! -nargs=*	VimFoldr	<args>
    1              0.000003  com! -nargs=*	VimFoldt	<args>
    1              0.000001 endif
                            
                            " commands not picked up by the generator (due to non-standard format)
    1              0.000005 syn keyword vimCommand contained	py3
                            
                            " Deprecated variable options {{{2
    1              0.000002 if exists("g:vim_minlines")
                             let g:vimsyn_minlines= g:vim_minlines
                            endif
    1              0.000002 if exists("g:vim_maxlines")
                             let g:vimsyn_maxlines= g:vim_maxlines
                            endif
    1              0.000002 if exists("g:vimsyntax_noerror")
                             let g:vimsyn_noerror= g:vimsyntax_noerror
                            endif
                            
                            " Variable options {{{2
    1              0.000002 if exists("g:vim_maxlines")
                             let s:vimsyn_maxlines= g:vim_maxlines
                            else
    1              0.000002  let s:vimsyn_maxlines= 60
    1              0.000001 endif
                            
                            " Numbers {{{2
                            " =======
    1              0.000023 syn match vimNumber	"\<\d\+\%(\.\d\+\%([eE][+-]\=\d\+\)\=\)\=" skipwhite nextgroup=vimGlobal,vimSubst,vimCommand
    1              0.000011 syn match vimNumber	"-\d\+\%(\.\d\+\%([eE][+-]\=\d\+\)\=\)\="  skipwhite nextgroup=vimGlobal,vimSubst,vimCommand
    1              0.000003 syn match vimNumber	"\<0[xX]\x\+"
    1              0.000004 syn match vimNumber	"\%(^\|[^a-zA-Z]\)\zs#\x\{6}"
                            
                            " All vimCommands are contained by vimIsCommands. {{{2
    1              0.000050 syn match vimCmdSep	"[:|]\+"	skipwhite nextgroup=vimAddress,vimAutoCmd,vimIsCommand,vimExtCmd,vimFilter,vimLet,vimMap,vimMark,vimSet,vimSyntax,vimUserCmd
    1              0.000011 syn match vimIsCommand	"\<\h\w*\>"	contains=vimCommand
    1              0.000006 syn match vimVar        contained	"\<\h[a-zA-Z0-9#_]*\>"
    1              0.000006 syn match vimVar		"\<[bwglstav]:\h[a-zA-Z0-9#_]*\>"
    1              0.000006 syn match vimFBVar      contained   "\<[bwglstav]:\h[a-zA-Z0-9#_]*\>"
    1              0.000004 syn keyword vimCommand  contained	in
                            
                            " Insertions And Appends: insert append {{{2
                            " =======================
    1              0.000017 syn region vimInsert	matchgroup=vimCommand start="^[: \t]*\(\d\+\(,\d\+\)\=\)\=a\%[ppend]$"	matchgroup=vimCommand end="^\.$""
    1              0.000012 syn region vimInsert	matchgroup=vimCommand start="^[: \t]*\(\d\+\(,\d\+\)\=\)\=c\%[hange]$"	matchgroup=vimCommand end="^\.$""
    1              0.000011 syn region vimInsert	matchgroup=vimCommand start="^[: \t]*\(\d\+\(,\d\+\)\=\)\=i\%[nsert]$"	matchgroup=vimCommand end="^\.$""
                            
                            " Behave! {{{2
                            " =======
    1              0.000016 syn match   vimBehave	"\<be\%[have]\>" skipwhite nextgroup=vimBehaveModel,vimBehaveError
    1              0.000002 syn keyword vimBehaveModel contained	mswin	xterm
    1              0.000004 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_nobehaveerror")
    1              0.000003  syn match   vimBehaveError contained	"[^ ]\+"
    1              0.000001 endif
                            
                            " Filetypes {{{2
                            " =========
    1              0.000017 syn match   vimFiletype	"\<filet\%[ype]\(\s\+\I\i*\)*"	skipwhite contains=vimFTCmd,vimFTOption,vimFTError
    1              0.000003 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_vimFTError")
    1              0.000003  syn match   vimFTError  contained	"\I\i*"
    1              0.000001 endif
    1              0.000002 syn keyword vimFTCmd    contained	filet[ype]
    1              0.000002 syn keyword vimFTOption contained	detect indent off on plugin
                            
                            " Augroup : vimAugroupError removed because long augroups caused sync'ing problems. {{{2
                            " ======= : Trade-off: Increasing synclines with slower editing vs augroup END error checking.
    1              0.000120 syn cluster vimAugroupList	contains=vimAugroup,vimIsCommand,vimCommand,vimUserCmd,vimExecute,vimNotFunc,vimFuncName,vimFunction,vimFunctionError,vimLineComment,vimMap,vimSpecFile,vimOper,vimNumber,vimOperParen,vimComment,vimString,vimSubst,vimMark,vimRegister,vimAddress,vimFilter,vimCmplxRepeat,vimComment,vimLet,vimSet,vimAutoCmd,vimRegion,vimSynLine,vimNotation,vimCtrlChar,vimFuncVar,vimContinue
    1              0.000003 if exists("g:vimsyn_folding") && g:vimsyn_folding =~# 'a'
                             syn region  vimAugroup	fold matchgroup=vimAugroupKey start="\<aug\%[roup]\>\ze\s\+\K\k*" end="\<aug\%[roup]\>\ze\s\+[eE][nN][dD]\>"	contains=vimAutoCmd,@vimAugroupList
                            else
    1              0.000012  syn region  vimAugroup	matchgroup=vimAugroupKey start="\<aug\%[roup]\>\ze\s\+\K\k*" end="\<aug\%[roup]\>\ze\s\+[eE][nN][dD]\>"		contains=vimAutoCmd,@vimAugroupList
    1              0.000001 endif
    1              0.000004 syn match   vimAugroup	"aug\%[roup]!"	contains=vimAugroupKey
    1              0.000004 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_noaugrouperror")
    1              0.000007  syn match   vimAugroupError	"\<aug\%[roup]\>\s\+[eE][nN][dD]\>"
    1              0.000001 endif
    1              0.000002 syn keyword vimAugroupKey contained	aug[roup]
                            
                            " Operators: {{{2
                            " =========
    1              0.000033 syn cluster	vimOperGroup	contains=vimEnvvar,vimFunc,vimFuncVar,vimOper,vimOperParen,vimNumber,vimString,vimRegister,vimContinue
    1              0.000012 syn match	vimOper	"\(==\|!=\|>=\|<=\|=\~\|!\~\|>\|<\|=\)[?#]\{0,2}"	skipwhite nextgroup=vimString,vimSpecFile
    1              0.000007 syn match	vimOper	"||\|&&\|[-+.]"	skipwhite nextgroup=vimString,vimSpecFile
    1              0.000011 syn region	vimOperParen 	matchgroup=vimParenSep	start="(" end=")" contains=@vimOperGroup
    1              0.000022 syn region	vimOperParen	matchgroup=vimSep		start="{" end="}" contains=@vimOperGroup nextgroup=vimVar,vimFuncVar
    1              0.000004 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_noopererror")
    1              0.000005  syn match	vimOperError	")"
    1              0.000001 endif
                            
                            " Functions : Tag is provided for those who wish to highlight tagged functions {{{2
                            " =========
    1              0.000025 syn cluster	vimFuncList	contains=vimCommand,vimFunctionError,vimFuncKey,Tag,vimFuncSID
    1              0.000116 syn cluster	vimFuncBodyList	contains=vimAbb,vimAddress,vimAugroupKey,vimAutoCmd,vimCmplxRepeat,vimComment,vimContinue,vimCtrlChar,vimEcho,vimEchoHL,vimExecute,vimIf,vimIsCommand,vimFBVar,vimFunc,vimFunction,vimFuncVar,vimGlobal,vimHighlight,vimIsCommand,vimLet,vimLineComment,vimMap,vimMark,vimNorm,vimNotation,vimNotFunc,vimNumber,vimOper,vimOperParen,vimRegion,vimRegister,vimSet,vimSpecFile,vimString,vimSubst,vimSynLine,vimUnmap,vimUserCommand
    1              0.000034 syn match	vimFunction	"\<fu\%[nction]!\=\s\+\%(<[sS][iI][dD]>\|[sSgGbBwWtTlL]:\)\=\%(\i\|[#.]\|{.\{-1,}}\)*\ze\s*("	contains=@vimFuncList nextgroup=vimFuncBody
                            
    1              0.000003 if exists("g:vimsyn_folding") && g:vimsyn_folding =~# 'f'
                             syn region	vimFuncBody  contained	fold start="\ze\s*("	matchgroup=vimCommand end="\<\(endf\>\|endfu\%[nction]\>\)"		contains=@vimFuncBodyList
                            else
    1              0.000010  syn region	vimFuncBody  contained	start="\ze\s*("	matchgroup=vimCommand end="\<\(endf\>\|endfu\%[nction]\>\)"		contains=@vimFuncBodyList
    1              0.000001 endif
    1              0.000006 syn match	vimFuncVar   contained	"a:\(\K\k*\|\d\+\)"
    1              0.000003 syn match	vimFuncSID   contained	"\c<sid>\|\<s:"
    1              0.000005 syn keyword	vimFuncKey   contained	fu[nction]
    1              0.000005 syn match	vimFuncBlank contained	"\s\+"
                            
    1              0.000005 syn keyword	vimPattern   contained	start	skip	end
                            
                            " Special Filenames, Modifiers, Extension Removal: {{{2
                            " ===============================================
    1              0.000009 syn match	vimSpecFile	"<c\(word\|WORD\)>"	nextgroup=vimSpecFileMod,vimSubst
    1              0.000006 syn match	vimSpecFile	"<\([acs]file\|amatch\|abuf\)>"	nextgroup=vimSpecFileMod,vimSubst
    1              0.000005 syn match	vimSpecFile	"\s%[ \t:]"ms=s+1,me=e-1	nextgroup=vimSpecFileMod,vimSubst
    1              0.000009 syn match	vimSpecFile	"\s%$"ms=s+1	nextgroup=vimSpecFileMod,vimSubst
    1              0.000007 syn match	vimSpecFile	"\s%<"ms=s+1,me=e-1	nextgroup=vimSpecFileMod,vimSubst
    1              0.000005 syn match	vimSpecFile	"#\d\+\|[#%]<\>"	nextgroup=vimSpecFileMod,vimSubst
    1              0.000003 syn match	vimSpecFileMod	"\(:[phtre]\)\+"	contained
                            
                            " User-Specified Commands: {{{2
                            " =======================
    1              0.000074 syn cluster	vimUserCmdList	contains=vimAddress,vimSyntax,vimHighlight,vimAutoCmd,vimCmplxRepeat,vimComment,vimCtrlChar,vimEscapeBrace,vimFilter,vimFunc,vimFuncName,vimFunction,vimFunctionError,vimIsCommand,vimMark,vimNotation,vimNumber,vimOper,vimRegion,vimRegister,vimLet,vimSet,vimSetEqual,vimSetString,vimSpecFile,vimString,vimSubst,vimSubstRep,vimSubstRange,vimSynLine
    1              0.000002 syn keyword	vimUserCommand	contained	com[mand]
    1              0.000014 syn match	vimUserCmd	"\<com\%[mand]!\=\>.*$"	contains=vimUserAttrb,vimUserAttrbError,vimUserCommand,@vimUserCmdList
    1              0.000003 syn match	vimUserAttrbError	contained	"-\a\+\ze\s"
    1              0.000016 syn match	vimUserAttrb	contained	"-nargs=[01*?+]"	contains=vimUserAttrbKey,vimOper
    1              0.000018 syn match	vimUserAttrb	contained	"-complete="		contains=vimUserAttrbKey,vimOper nextgroup=vimUserAttrbCmplt,vimUserCmdError
    1              0.000011 syn match	vimUserAttrb	contained	"-range\(=%\|=\d\+\)\="	contains=vimNumber,vimOper,vimUserAttrbKey
    1              0.000011 syn match	vimUserAttrb	contained	"-count\(=\d\+\)\="	contains=vimNumber,vimOper,vimUserAttrbKey
    1              0.000009 syn match	vimUserAttrb	contained	"-bang\>"		contains=vimOper,vimUserAttrbKey
    1              0.000009 syn match	vimUserAttrb	contained	"-bar\>"		contains=vimOper,vimUserAttrbKey
    1              0.000012 syn match	vimUserAttrb	contained	"-buffer\>"		contains=vimOper,vimUserAttrbKey
    1              0.000009 syn match	vimUserAttrb	contained	"-register\>"		contains=vimOper,vimUserAttrbKey
    1              0.000004 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_nousercmderror")
    1              0.000003  syn match	vimUserCmdError	contained	"\S\+\>"
    1              0.000001 endif
    1              0.000001 syn case ignore
    1              0.000008 syn keyword	vimUserAttrbKey   contained	bar	ban[g]	cou[nt]	ra[nge] com[plete]	n[args]	re[gister]
    1              0.000013 syn keyword	vimUserAttrbCmplt contained	augroup buffer behave color command compiler cscope dir environment event expression file file_in_path filetype function help highlight history locale mapping menu option packadd shellcmd sign syntax syntime tag tag_listfiles user var
    1              0.000008 syn keyword	vimUserAttrbCmplt contained	custom customlist nextgroup=vimUserAttrbCmpltFunc,vimUserCmdError
    1              0.000007 syn match	vimUserAttrbCmpltFunc contained	",\%([sS]:\|<[sS][iI][dD]>\)\=\%(\h\w*\%(#\h\w*\)\+\|\h\w*\)"hs=s+1 nextgroup=vimUserCmdError
                            
    1              0.000001 syn case match
    1              0.000006 syn match	vimUserAttrbCmplt contained	"custom,\u\w*"
                            
                            " Lower Priority Comments: after some vim commands... {{{2
                            " =======================
    1              0.000011 syn match	vimComment	excludenl +\s"[^\-:.%#=*].*$+lc=1	contains=@vimCommentGroup,vimCommentString
    1              0.000005 syn match	vimComment	+\<endif\s\+".*$+lc=5	contains=@vimCommentGroup,vimCommentString
    1              0.000007 syn match	vimComment	+\<else\s\+".*$+lc=4	contains=@vimCommentGroup,vimCommentString
    1              0.000005 syn region	vimCommentString	contained oneline start='\S\s\+"'ms=e	end='"'
                            
                            " Environment Variables: {{{2
                            " =====================
    1              0.000002 syn match	vimEnvvar	"\$\I\i*"
    1              0.000002 syn match	vimEnvvar	"\${\I\i*}"
                            
                            " In-String Specials: {{{2
                            " Try to catch strings, if nothing else matches (therefore it must precede the others!)
                            "  vimEscapeBrace handles ["]  []"] (ie. "s don't terminate string inside [])
    1              0.000010 syn region	vimEscapeBrace	oneline   contained transparent start="[^\\]\(\\\\\)*\[\zs\^\=\]\=" skip="\\\\\|\\\]" end="]"me=e-1
    1              0.000006 syn match	vimPatSepErr	contained	"\\)"
    1              0.000005 syn match	vimPatSep	contained	"\\|"
    1              0.000015 syn region	vimPatSepZone	oneline   contained   matchgroup=vimPatSepZ start="\\%\=\ze(" skip="\\\\" end="\\)\|[^\]['"]"	contains=@vimStringGroup
    1              0.000013 syn region	vimPatRegion	contained transparent matchgroup=vimPatSepR start="\\[z%]\=(" end="\\)"	contains=@vimSubstList oneline
    1              0.000005 syn match	vimNotPatSep	contained	"\\\\"
    1              0.000007 syn cluster	vimStringGroup	contains=vimEscapeBrace,vimPatSep,vimNotPatSep,vimPatSepErr,vimPatSepZone,@Spell
    1              0.000011 syn region	vimString	oneline keepend	start=+[^a-zA-Z>!\\@]"+lc=1 skip=+\\\\\|\\"+ end=+"+	contains=@vimStringGroup
    1              0.000005 syn region	vimString	oneline keepend	start=+[^a-zA-Z>!\\@]'+lc=1 end=+'+
    1              0.000006 syn region	vimString	oneline	start=+=!+lc=1	skip=+\\\\\|\\!+ end=+!+	contains=@vimStringGroup
    1              0.000006 syn region	vimString	oneline	start="=+"lc=1	skip="\\\\\|\\+" end="+"	contains=@vimStringGroup
    1              0.000009 syn region	vimString	oneline	start="\s/\s*\A"lc=1 skip="\\\\\|\\+" end="/"	contains=@vimStringGroup
    1              0.000008 syn match	vimString	contained	+"[^"]*\\$+	skipnl nextgroup=vimStringCont
    1              0.000004 syn match	vimStringCont	contained	+\(\\\\\|.\)\{-}[^\\]"+
                            
                            " Substitutions: {{{2
                            " =============
    1              0.000015 syn cluster	vimSubstList	contains=vimPatSep,vimPatRegion,vimPatSepErr,vimSubstTwoBS,vimSubstRange,vimNotation
    1              0.000012 syn cluster	vimSubstRepList	contains=vimSubstSubstr,vimSubstTwoBS,vimNotation
    1              0.000009 syn cluster	vimSubstList	add=vimCollection
    1              0.000012 syn match	vimSubst	"\(:\+\s*\|^\s*\||\s*\)\<\%(\<s\%[ubstitute]\>\|\<sm\%[agic]\>\|\<sno\%[magic]\>\)[:#[:alpha:]]\@!" nextgroup=vimSubstPat
    1              0.000012 syn match	vimSubst	"\%(^\|[^\\]\)\<s\%[ubstitute]\>[:#[:alpha:]]\@!"	nextgroup=vimSubstPat contained
    1              0.000005 syn match	vimSubst	"/\zs\<s\%[ubstitute]\>\ze/"		nextgroup=vimSubstPat
    1              0.000007 syn match	vimSubst	"\(:\+\s*\|^\s*\)s\ze#.\{-}#.\{-}#"		nextgroup=vimSubstPat
    1              0.000008 syn match	vimSubst1       contained	"\<s\%[ubstitute]\>"	nextgroup=vimSubstPat
    1              0.000024 syn region	vimSubstPat     contained	matchgroup=vimSubstDelim start="\z([^a-zA-Z( \t[\]&]\)"rs=s+1 skip="\\\\\|\\\z1" end="\z1"re=e-1,me=e-1	 contains=@vimSubstList	nextgroup=vimSubstRep4	oneline
    1              0.000018 syn region	vimSubstRep4    contained	matchgroup=vimSubstDelim start="\z(.\)" skip="\\\\\|\\\z1" end="\z1" matchgroup=vimNotation end="<[cC][rR]>" contains=@vimSubstRepList	nextgroup=vimSubstFlagErr	oneline
    1              0.000014 syn region	vimCollection   contained transparent	start="\\\@<!\[" skip="\\\[" end="\]"	contains=vimCollClass
    1              0.000007 syn match	vimCollClassErr contained	"\[:.\{-\}:\]"
    1              0.000008 syn match	vimCollClass    contained transparent	"\[:\(alnum\|alpha\|blank\|cntrl\|digit\|graph\|lower\|print\|punct\|space\|upper\|xdigit\|return\|tab\|escape\|backspace\):\]"
    1              0.000002 syn match	vimSubstSubstr  contained	"\\z\=\d"
    1              0.000002 syn match	vimSubstTwoBS   contained	"\\\\"
    1              0.000007 syn match	vimSubstFlagErr contained	"[^< \t\r|]\+" contains=vimSubstFlags
    1              0.000003 syn match	vimSubstFlags   contained	"[&cegiIpr]\+"
                            
                            " 'String': {{{2
    1              0.000003 syn match	vimString	"[^(,]'[^']\{-}\zs'"
                            
                            " Marks, Registers, Addresses, Filters: {{{2
    1              0.000018 syn match	vimMark	"'[a-zA-Z0-9]\ze[-+,!]"	nextgroup=vimOper,vimMarkNumber,vimSubst
    1              0.000011 syn match	vimMark	"'[<>]\ze[-+,!]"		nextgroup=vimOper,vimMarkNumber,vimSubst
    1              0.000011 syn match	vimMark	",\zs'[<>]\ze"		nextgroup=vimOper,vimMarkNumber,vimSubst
    1              0.000011 syn match	vimMark	"[!,:]\zs'[a-zA-Z0-9]"	nextgroup=vimOper,vimMarkNumber,vimSubst
    1              0.000011 syn match	vimMark	"\<norm\%[al]\s\zs'[a-zA-Z0-9]"	nextgroup=vimOper,vimMarkNumber,vimSubst
    1              0.000010 syn match	vimMarkNumber	"[-+]\d\+"		nextgroup=vimSubst contained contains=vimOper
    1              0.000006 syn match	vimPlainMark contained	"'[a-zA-Z0-9]"
                            
    1              0.000008 syn match	vimRegister	'[^,;[{: \t]\zs"[a-zA-Z0-9.%#:_\-/]\ze[^a-zA-Z_":0-9]'
    1              0.000004 syn match	vimRegister	'\<norm\s\+\zs"[a-zA-Z0-9]'
    1              0.000006 syn match	vimRegister	'\<normal\s\+\zs"[a-zA-Z0-9]'
    1              0.000002 syn match	vimRegister	'@"'
    1              0.000009 syn match	vimPlainRegister contained	'"[a-zA-Z0-9\-:.%#*+=]'
                            
    1              0.000004 syn match	vimAddress	",\zs[.$]"	skipwhite nextgroup=vimSubst1
    1              0.000022 syn match	vimAddress	"%\ze\a"	skipwhite nextgroup=vimString,vimSubst1
                            
    1              0.000008 syn match	vimFilter contained	"^!.\{-}\(|\|$\)"		contains=vimSpecFile
    1              0.000023 syn match	vimFilter contained	"\A!.\{-}\(|\|$\)"ms=s+1	contains=vimSpecFile,vimFunction,vimFuncName,vimOperParen
                            
                            " Complex repeats (:h complex-repeat) {{{2
    1              0.000004 syn match	vimCmplxRepeat	'[^a-zA-Z_/\\()]q[0-9a-zA-Z"]\>'lc=1
    1              0.000004 syn match	vimCmplxRepeat	'@[0-9a-z".=@:]\ze\($\|[^a-zA-Z]\>\)'
                            
                            " Set command and associated set-options (vimOptions) with comment {{{2
    1              0.000033 syn region	vimSet		matchgroup=vimCommand start="\<\%(setl\%[ocal]\|setg\%[lobal]\|se\%[t]\)\>" skip="\%(\\\\\)*\\." end="$" matchgroup=vimNotation end="<[cC][rR]>" keepend oneline contains=vimSetEqual,vimOption,vimErrSetting,vimComment,vimSetString,vimSetMod
    1              0.000036 syn region	vimSetEqual	contained	start="[=:]\|[-+^]=" skip="\\\\\|\\\s" end="[| \t]\|$"me=e-1 contains=vimCtrlChar,vimSetSep,vimNotation,vimEnvvar oneline
    1              0.000008 syn region	vimSetString	contained	start=+="+hs=s+1	skip=+\\\\\|\\"+  end=+"+	contains=vimCtrlChar
    1              0.000009 syn match	vimSetSep	contained	"[,:]" skipwhite nextgroup=vimCommand
    1              0.000007 syn match	vimSetMod	contained	"&vim\=\|[!&?<]\|all&"
                            
                            " Let {{{2
                            " ===
    1              0.000018 syn keyword	vimLet	let	unl[et]	skipwhite nextgroup=vimVar,vimFuncVar
                            
                            " Abbreviations {{{2
                            " =============
    1              0.000016 syn keyword vimAbb	ab[breviate] ca[bbrev] inorea[bbrev] cnorea[bbrev] norea[bbrev] ia[bbrev] skipwhite nextgroup=vimMapMod,vimMapLhs
                            
                            " Autocmd {{{2
                            " =======
    1              0.000050 syn match	vimAutoEventList	contained	"\(!\s\+\)\=\(\a\+,\)*\a\+"	contains=vimAutoEvent,nvimAutoEvent nextgroup=vimAutoCmdSpace
    1              0.000008 syn match	vimAutoCmdSpace	contained	"\s\+"	nextgroup=vimAutoCmdSfxList
    1              0.000033 syn match	vimAutoCmdSfxList	contained	"\S*"
    1              0.000009 syn keyword	vimAutoCmd	au[tocmd] do[autocmd] doautoa[ll]	skipwhite nextgroup=vimAutoEventList
                            
                            " Echo and Execute -- prefer strings! {{{2
                            " ================
    1              0.000030 syn region	vimEcho	oneline excludenl matchgroup=vimCommand start="\<ec\%[ho]\>" skip="\(\\\\\)*\\|" end="$\||" contains=vimFunc,vimFuncVar,vimString,vimVar
    1              0.000061 syn region	vimExecute	oneline excludenl matchgroup=vimCommand start="\<exe\%[cute]\>" skip="\(\\\\\)*\\|" end="$\||\|<[cC][rR]>" contains=vimFuncVar,vimIsCommand,vimOper,vimNotation,vimOperParen,vimString,vimVar
    1              0.000029 syn match	vimEchoHL	"echohl\="	skipwhite nextgroup=vimGroup,vimHLGroup,vimEchoHLNone,vimOnlyHLGroup,nvimHLGroup
    1              0.000001 syn case ignore
    1              0.000002 syn keyword	vimEchoHLNone	none
    1              0.000001 syn case match
                            
                            " Maps {{{2
                            " ====
    1              0.000018 syn match	vimMap		"\<map\>!\=\ze\s*[^(]" skipwhite nextgroup=vimMapMod,vimMapLhs
    1              0.000029 syn keyword	vimMap		cm[ap] cno[remap] im[ap] ino[remap] lm[ap] ln[oremap] nm[ap] nn[oremap] no[remap] om[ap] ono[remap] smap snor[emap] vm[ap] vn[oremap] xm[ap] xn[oremap] skipwhite nextgroup=vimMapBang,vimMapMod,vimMapLhs
    1              0.000010 syn keyword	nvimMap		tn[oremap] tm[ap] skipwhite nextgroup=vimMapBang,vimMapMod,vimMapLhs
    1              0.000006 syn keyword	vimMap		mapc[lear] smapc[lear]
    1              0.000014 syn keyword	vimUnmap		cu[nmap] iu[nmap] lu[nmap] nun[map] ou[nmap] sunm[ap] unm[ap] unm[ap] vu[nmap] xu[nmap] skipwhite nextgroup=vimMapBang,vimMapMod,vimMapLhs
    1              0.000008 syn keyword	nvimUnmap 		tunm[ap] skipwhite nextgroup=vimMapBang,vimMapMod,vimMapLhs
    1              0.000025 syn match	vimMapLhs	contained	"\S\+"			contains=vimNotation,vimCtrlChar skipwhite nextgroup=vimMapRhs
    1              0.000006 syn match	vimMapBang	contained	"!"			skipwhite nextgroup=vimMapMod,vimMapLhs
    1              0.000026 syn match	vimMapMod	contained	"\c<\(buffer\|expr\|\(local\)\=leader\|nowait\|plug\|script\|sid\|unique\|silent\)\+>" contains=vimMapModKey,vimMapModErr skipwhite nextgroup=vimMapMod,vimMapLhs
    1              0.000037 syn match	vimMapRhs	contained	".*" contains=vimNotation,vimCtrlChar	skipnl nextgroup=vimMapRhsExtend
    1              0.000016 syn match	vimMapRhsExtend	contained	"^\s*\\.*$"			contains=vimContinue
    1              0.000001 syn case ignore
    1              0.000008 syn keyword	vimMapModKey	contained	buffer	expr	leader	localleader	nowait	plug	script	sid	silent	unique
    1              0.000001 syn case match
                            
                            " Menus {{{2
                            " =====
    1              0.000029 syn cluster	vimMenuList contains=vimMenuBang,vimMenuPriority,vimMenuName,vimMenuMod
    1              0.000022 syn keyword	vimCommand	am[enu] an[oremenu] aun[menu] cme[nu] cnoreme[nu] cunme[nu] ime[nu] inoreme[nu] iunme[nu] me[nu] nme[nu] nnoreme[nu] noreme[nu] nunme[nu] ome[nu] onoreme[nu] ounme[nu] unme[nu] vme[nu] vnoreme[nu] vunme[nu] skipwhite nextgroup=@vimMenuList
    1              0.000017 syn match	vimMenuName	"[^ \t\\<]\+"	contained nextgroup=vimMenuNameMore,vimMenuMap
    1              0.000004 syn match	vimMenuPriority	"\d\+\(\.\d\+\)*"	contained skipwhite nextgroup=vimMenuName
    1              0.000011 syn match	vimMenuNameMore	"\c\\\s\|<tab>\|\\\."	contained nextgroup=vimMenuName,vimMenuNameMore contains=vimNotation
    1              0.000013 syn match	vimMenuMod    contained	"\c<\(script\|silent\)\+>"  skipwhite contains=vimMapModKey,vimMapModErr nextgroup=@vimMenuList
    1              0.000007 syn match	vimMenuMap	"\s"	contained skipwhite nextgroup=vimMenuRhs
    1              0.000012 syn match	vimMenuRhs	".*$"	contained contains=vimString,vimComment,vimIsCommand
    1              0.000003 syn match	vimMenuBang	"!"	contained skipwhite nextgroup=@vimMenuList
                            
                            " Angle-Bracket Notation (tnx to Michael Geddes) {{{2
                            " ======================
    1              0.000001 syn case ignore
    1              0.000026 syn match	vimNotation	"\(\\\|<lt>\)\=<\([scamd]-\)\{0,4}x\=\(f\d\{1,2}\|[^ \t:]\|cr\|lf\|linefeed\|return\|k\=del\%[ete]\|bs\|backspace\|tab\|esc\|right\|left\|help\|undo\|insert\|ins\|k\=home\|k\=end\|kplus\|kminus\|kdivide\|kmultiply\|kenter\|kpoint\|space\|k\=\(page\)\=\(\|down\|up\|k\d\>\)\)>" contains=vimBracket
    1              0.000017 syn match	vimNotation	"\(\\\|<lt>\)\=<\([scam2-4]-\)\{0,4}\(right\|left\|middle\)\(mouse\)\=\(drag\|release\)\=>"	contains=vimBracket
    1              0.000014 syn match	vimNotation	"\(\\\|<lt>\)\=<\(bslash\|plug\|sid\|space\|bar\|nop\|nul\|lt\)>"		contains=vimBracket
    1              0.000013 syn match	vimNotation	'\(\\\|<lt>\)\=<C-R>[0-9a-z"%#:.\-=]'he=e-1			contains=vimBracket
    1              0.000015 syn match	vimNotation	'\(\\\|<lt>\)\=<\%(q-\)\=\(line[12]\|count\|bang\|reg\|args\|mods\|f-args\|f-mods\|lt\)>'	contains=vimBracket
    1              0.000018 syn match	vimNotation	"\(\\\|<lt>\)\=<\([cas]file\|abuf\|amatch\|cword\|cWORD\|client\)>"		contains=vimBracket
    1              0.000006 syn match	vimBracket contained	"[\\<>]"
    1              0.000001 syn case match
                            
                            " User Function Highlighting {{{2
                            " (following Gautam Iyer's suggestion)
                            " ==========================
    1              0.000019 syn match vimFunc		"\%(\%([sSgGbBwWtTlL]:\|<[sS][iI][dD]>\)\=\%([a-zA-Z0-9_]\+\.\)*\I[a-zA-Z0-9_.]*\)\ze\s*("		contains=vimFuncName,vimUserFunc,vimExecute
    1              0.000013 syn match vimUserFunc contained	"\%(\%([sSgGbBwWtTlL]:\|<[sS][iI][dD]>\)\=\%([a-zA-Z0-9_]\+\.\)*\I[a-zA-Z0-9_.]*\)\|\<\u[a-zA-Z0-9.]*\>\|\<if\>"	contains=vimNotation
    1              0.000023 syn match vimNotFunc	"\<if\>\|\<el\%[seif]\>\|\<return\>\|\<while\>"
                            
                            " Errors And Warnings: {{{2
                            " ====================
    1              0.000005 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimfunctionerror")
    1              0.000013  syn match	vimFunctionError	"\s\zs[a-z0-9]\i\{-}\ze\s*("			contained contains=vimFuncKey,vimFuncBlank
                            " syn match	vimFunctionError	"\s\zs\%(<[sS][iI][dD]>\|[sSgGbBwWtTlL]:\)[0-9]\i\{-}\ze\s*("	contained contains=vimFuncKey,vimFuncBlank
    1              0.000009  syn match	vimElseIfErr	"\<else\s\+if\>"
    1              0.000007  syn match	vimBufnrWarn	/\<bufnr\s*(\s*["']\.['"]\s*)/
    1              0.000001 endif
                            
                            " Norm {{{2
                            " ====
    1              0.000008 syn match	vimNorm		"\<norm\%[al]!\=" skipwhite nextgroup=vimNormCmds
    1              0.000003 syn match	vimNormCmds contained	".*$"
                            
                            " Syntax {{{2
                            "=======
    1              0.000011 syn match	vimGroupList	contained	"@\=[^ \t,]*"	contains=vimGroupSpecial,vimPatSep
    1              0.000018 syn match	vimGroupList	contained	"@\=[^ \t,]*,"	nextgroup=vimGroupList contains=vimGroupSpecial,vimPatSep
    1              0.000003 syn keyword	vimGroupSpecial	contained	ALL	ALLBUT	CONTAINED	TOP
    1              0.000004 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimsynerror")
    1              0.000006  syn match	vimSynError	contained	"\i\+"
    1              0.000009  syn match	vimSynError	contained	"\i\+="	nextgroup=vimGroupList
    1              0.000001 endif
    1              0.000029 syn match	vimSynContains	contained	"\<contain\(s\|edin\)="	nextgroup=vimGroupList
    1              0.000014 syn match	vimSynKeyContainedin	contained	"\<containedin="	nextgroup=vimGroupList
    1              0.000012 syn match	vimSynNextgroup	contained	"nextgroup="	nextgroup=vimGroupList
                            
    1              0.000021 syn match	vimSyntax	"\<sy\%[ntax]\>"	contains=vimCommand skipwhite nextgroup=vimSynType,vimComment
    1              0.000021 syn match	vimAuSyntax	contained	"\s+sy\%[ntax]"	contains=vimCommand skipwhite nextgroup=vimSynType,vimComment
    1              0.000006 syn cluster vimFuncBodyList add=vimSyntax
                            
                            " Syntax: case {{{2
    1              0.000013 syn keyword	vimSynType	contained	case	skipwhite nextgroup=vimSynCase,vimSynCaseError
    1              0.000004 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimsyncaseerror")
    1              0.000003  syn match	vimSynCaseError	contained	"\i\+"
    1              0.000001 endif
    1              0.000002 syn keyword	vimSynCase	contained	ignore	match
                            
                            " Syntax: clear {{{2
    1              0.000012 syn keyword	vimSynType	contained	clear	skipwhite nextgroup=vimGroupList
                            
                            " Syntax: cluster {{{2
    1              0.000009 syn keyword	vimSynType	contained	cluster	skipwhite nextgroup=vimClusterName
    1              0.000027 syn region	vimClusterName	contained	matchgroup=vimGroupName start="\h\w*" skip="\\\\\|\\|" matchgroup=vimSep end="$\||" contains=vimGroupAdd,vimGroupRem,vimSynContains,vimSynError
    1              0.000012 syn match	vimGroupAdd	contained	"add="	nextgroup=vimGroupList
    1              0.000026 syn match	vimGroupRem	contained	"remove="	nextgroup=vimGroupList
    1              0.000011 syn cluster vimFuncBodyList add=vimSynType,vimGroupAdd,vimGroupRem
                            
                            " Syntax: iskeyword {{{2
    1              0.000009 syn keyword	vimSynType	contained	iskeyword	skipwhite nextgroup=vimIskList
    1              0.000007 syn match	vimIskList	contained	'\S\+'	contains=vimIskSep
    1              0.000002 syn match	vimIskSep	contained	','
                            
                            " Syntax: include {{{2
    1              0.000011 syn keyword	vimSynType	contained	include	skipwhite nextgroup=vimGroupList
    1              0.000009 syn cluster vimFuncBodyList add=vimSynType
                            
                            " Syntax: keyword {{{2
    1              0.000014 syn cluster	vimSynKeyGroup	contains=vimSynNextgroup,vimSynKeyOpt,vimSynKeyContainedin
    1              0.000011 syn keyword	vimSynType	contained	keyword	skipwhite nextgroup=vimSynKeyRegion
    1              0.000014 syn region	vimSynKeyRegion	contained oneline keepend	matchgroup=vimGroupName start="\h\w*" skip="\\\\\|\\|" matchgroup=vimSep end="|\|$" contains=@vimSynKeyGroup
    1              0.000006 syn match	vimSynKeyOpt	contained	"\<\(conceal\|contained\|transparent\|skipempty\|skipwhite\|skipnl\)\>"
    1              0.000009 syn cluster vimFuncBodyList add=vimSynType
                            
                            " Syntax: match {{{2
    1              0.000037 syn cluster	vimSynMtchGroup	contains=vimMtchComment,vimSynContains,vimSynError,vimSynMtchOpt,vimSynNextgroup,vimSynRegPat,vimNotation
    1              0.000009 syn keyword	vimSynType	contained	match	skipwhite nextgroup=vimSynMatchRegion
    1              0.000010 syn region	vimSynMatchRegion	contained keepend	matchgroup=vimGroupName start="\h\w*" matchgroup=vimSep end="|\|$" contains=@vimSynMtchGroup
    1              0.000010 syn match	vimSynMtchOpt	contained	"\<\(conceal\|transparent\|contained\|excludenl\|keepend\|skipempty\|skipwhite\|display\|extend\|skipnl\|fold\)\>"
    1              0.000005 if has("conceal")
    1              0.000016  syn match	vimSynMtchOpt	contained	"\<cchar="	nextgroup=vimSynMtchCchar
    1              0.000003  syn match	vimSynMtchCchar	contained	"\S"
    1              0.000001 endif
    1              0.000007 syn cluster vimFuncBodyList add=vimSynMtchGroup
                            
                            " Syntax: off and on {{{2
    1              0.000006 syn keyword	vimSynType	contained	enable	list	manual	off	on	reset
                            
                            " Syntax: region {{{2
    1              0.000023 syn cluster	vimSynRegPatGroup	contains=vimPatSep,vimNotPatSep,vimSynPatRange,vimSynNotPatRange,vimSubstSubstr,vimPatRegion,vimPatSepErr,vimNotation
    1              0.000043 syn cluster	vimSynRegGroup	contains=vimSynContains,vimSynNextgroup,vimSynRegOpt,vimSynReg,vimSynMtchGrp
    1              0.000011 syn keyword	vimSynType	contained	region	skipwhite nextgroup=vimSynRegion
    1              0.000013 syn region	vimSynRegion	contained keepend	matchgroup=vimGroupName start="\h\w*" skip="\\\\\|\\|" end="|\|$" contains=@vimSynRegGroup
    1              0.000010 syn match	vimSynRegOpt	contained	"\<\(conceal\(ends\)\=\|transparent\|contained\|excludenl\|skipempty\|skipwhite\|display\|keepend\|oneline\|extend\|skipnl\|fold\)\>"
    1              0.000011 syn match	vimSynReg	contained	"\(start\|skip\|end\)="he=e-1	nextgroup=vimSynRegPat
    1              0.000018 syn match	vimSynMtchGrp	contained	"matchgroup="	nextgroup=vimGroup,vimHLGroup,vimOnlyHLGroup,nvimHLGroup
    1              0.000020 syn region	vimSynRegPat	contained extend	start="\z([-`~!@#$%^&*_=+;:'",./?]\)"  skip="\\\\\|\\\z1"  end="\z1"  contains=@vimSynRegPatGroup skipwhite nextgroup=vimSynPatMod,vimSynReg
    1              0.000005 syn match	vimSynPatMod	contained	"\(hs\|ms\|me\|hs\|he\|rs\|re\)=[se]\([-+]\d\+\)\="
    1              0.000005 syn match	vimSynPatMod	contained	"\(hs\|ms\|me\|hs\|he\|rs\|re\)=[se]\([-+]\d\+\)\=," nextgroup=vimSynPatMod
    1              0.000003 syn match	vimSynPatMod	contained	"lc=\d\+"
    1              0.000003 syn match	vimSynPatMod	contained	"lc=\d\+," nextgroup=vimSynPatMod
    1              0.000009 syn region	vimSynPatRange	contained	start="\["	skip="\\\\\|\\]"   end="]"
    1              0.000003 syn match	vimSynNotPatRange	contained	"\\\\\|\\\["
    1              0.000003 syn match	vimMtchComment	contained	'"[^"]\+$'
    1              0.000009 syn cluster vimFuncBodyList add=vimSynType
                            
                            " Syntax: sync {{{2
                            " ============
    1              0.000033 syn keyword vimSynType	contained	sync	skipwhite	nextgroup=vimSyncC,vimSyncLines,vimSyncMatch,vimSyncError,vimSyncLinebreak,vimSyncLinecont,vimSyncRegion
    1              0.000004 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimsyncerror")
    1              0.000003  syn match	vimSyncError	contained	"\i\+"
    1              0.000003 endif
    1              0.000003 syn keyword	vimSyncC	contained	ccomment	clear	fromstart
    1              0.000010 syn keyword	vimSyncMatch	contained	match	skipwhite	nextgroup=vimSyncGroupName
    1              0.000009 syn keyword	vimSyncRegion	contained	region	skipwhite	nextgroup=vimSynReg
    1              0.000005 syn match	vimSyncLinebreak	contained	"\<linebreaks="	skipwhite	nextgroup=vimNumber
    1              0.000003 syn keyword	vimSyncLinecont	contained	linecont	skipwhite	nextgroup=vimSynRegPat
    1              0.000005 syn match	vimSyncLines	contained	"\(min\|max\)\=lines="	nextgroup=vimNumber
    1              0.000007 syn match	vimSyncGroupName	contained	"\h\w*"	skipwhite	nextgroup=vimSyncKey
    1              0.000011 syn match	vimSyncKey	contained	"\<groupthere\|grouphere\>"	skipwhite nextgroup=vimSyncGroup
    1              0.000008 syn match	vimSyncGroup	contained	"\h\w*"	skipwhite	nextgroup=vimSynRegPat,vimSyncNone
    1              0.000002 syn keyword	vimSyncNone	contained	NONE
                            
                            " Additional IsCommand, here by reasons of precedence {{{2
                            " ====================
    1              0.000019 syn match	vimIsCommand	"<Bar>\s*\a\+"	transparent contains=vimCommand,vimNotation
                            
                            " Highlighting {{{2
                            " ============
    1              0.000015 syn cluster	vimHighlightCluster		contains=vimHiLink,vimHiClear,vimHiKeyList,vimComment
    1              0.000004 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimhictermerror")
    1              0.000006  syn match	vimHiCtermError	contained	"[^0-9]\i*"
    1              0.000001 endif
    1              0.000009 syn match	vimHighlight	"\<hi\%[ghlight]\>"	skipwhite nextgroup=vimHiBang,@vimHighlightCluster
    1              0.000004 syn match	vimHiBang	contained	"!"	skipwhite nextgroup=@vimHighlightCluster
                            
    1              0.000005 syn match	vimHiGroup	contained	"\i\+"
    1              0.000001 syn case ignore
    1              0.000007 syn keyword	vimHiAttrib	contained	none bold inverse italic reverse standout underline undercurl
    1              0.000006 syn keyword	vimFgBgAttrib	contained	none bg background fg foreground
    1              0.000001 syn case match
    1              0.000010 syn match	vimHiAttribList	contained	"\i\+"	contains=vimHiAttrib
    1              0.000005 syn match	vimHiAttribList	contained	"\i\+,"he=e-1	contains=vimHiAttrib nextgroup=vimHiAttribList
    1              0.000003 syn case ignore
    1              0.000046 syn keyword	vimHiCtermColor	contained	black blue brown cyan darkblue darkcyan darkgray darkgreen darkgrey darkmagenta darkred darkyellow gray green grey lightblue lightcyan lightgray lightgreen lightgrey lightmagenta lightred magenta red white yellow
    1              0.000004 syn match	vimHiCtermColor	contained	"\<color\d\{1,3}\>"
                            
    1              0.000001 syn case match
    1              0.000011 syn match	vimHiFontname	contained	"[a-zA-Z\-*]\+"
    1              0.000007 syn match	vimHiGuiFontname	contained	"'[a-zA-Z\-* ]\+'"
    1              0.000006 syn match	vimHiGuiRgb	contained	"#\x\{6}"
                            
                            " Highlighting: hi group key=arg ... {{{2
    1              0.000054 syn cluster	vimHiCluster contains=vimGroup,vimHiGroup,vimHiTerm,vimHiCTerm,vimHiStartStop,vimHiCtermFgBg,vimHiGui,vimHiGuiFont,vimHiGuiFgBg,vimHiKeyError,vimNotation
    1              0.000008 syn region	vimHiKeyList	contained oneline start="\i\+" skip="\\\\\|\\|" end="$\||"	contains=@vimHiCluster
    1              0.000004 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_vimhikeyerror")
    1              0.000002  syn match	vimHiKeyError	contained	"\i\+="he=e-1
    1              0.000001 endif
    1              0.000004 syn match	vimHiTerm	contained	"\cterm="he=e-1		nextgroup=vimHiAttribList
    1              0.000013 syn match	vimHiStartStop	contained	"\c\(start\|stop\)="he=e-1	nextgroup=vimHiTermcap,vimOption
    1              0.000004 syn match	vimHiCTerm	contained	"\ccterm="he=e-1		nextgroup=vimHiAttribList
    1              0.000010 syn match	vimHiCtermFgBg	contained	"\ccterm[fb]g="he=e-1	nextgroup=vimHiNmbr,vimHiCtermColor,vimFgBgAttrib,vimHiCtermError
    1              0.000004 syn match	vimHiGui	contained	"\cgui="he=e-1		nextgroup=vimHiAttribList
    1              0.000003 syn match	vimHiGuiFont	contained	"\cfont="he=e-1		nextgroup=vimHiFontname
    1              0.000013 syn match	vimHiGuiFgBg	contained	"\cgui\%([fb]g\|sp\)="he=e-1	nextgroup=vimHiGroup,vimHiGuiFontname,vimHiGuiRgb,vimFgBgAttrib
    1              0.000009 syn match	vimHiTermcap	contained	"\S\+"		contains=vimNotation
    1              0.000002 syn match	vimHiNmbr	contained	'\d\+'
                            
                            " Highlight: clear {{{2
    1              0.000009 syn keyword	vimHiClear	contained	clear	nextgroup=vimHiGroup
                            
                            " Highlight: link {{{2
    1              0.000041 syn region	vimHiLink	contained oneline matchgroup=vimCommand start="\(\<hi\%[ghlight]\s\+\)\@<=\(\(def\%[ault]\s\+\)\=link\>\|\<def\>\)" end="$"	contains=vimHiGroup,vimGroup,vimHLGroup,vimNotation,vimOnlyHLGroup,nvimHLGroup
    1              0.000004 syn cluster vimFuncBodyList add=vimHiLink
                            
                            " Control Characters {{{2
                            " ==================
    1              0.000004 syn match	vimCtrlChar	"[--]"
                            
                            " Beginners - Patterns that involve ^ {{{2
                            " =========
    1              0.000013 syn match	vimLineComment	+^[ \t:]*".*$+	contains=@vimCommentGroup,vimCommentString,vimCommentTitle
    1              0.000016 syn match	vimCommentTitle	'"\s*\%([sS]:\|\h\w*#\)\=\u\w*\(\s\+\u\w*\)*:'hs=s+1	contained contains=vimCommentTitleLeader,vimTodo,@vimCommentGroup
    1              0.000006 syn match	vimContinue	"^\s*\\"
    1              0.000016 syn region	vimString	start="^\s*\\\z(['"]\)" skip='\\\\\|\\\z1' end="\z1" oneline keepend contains=@vimStringGroup,vimContinue
    1              0.000006 syn match	vimCommentTitleLeader	'"\s\+'ms=s+1	contained
                            
                            " Searches And Globals: {{{2
                            " ====================
    1              0.000011 syn match	vimSearch	'^\s*[/?].*'		contains=vimSearchDelim
    1              0.000003 syn match	vimSearchDelim	'^\s*\zs[/?]\|[/?]$'	contained
    1              0.000013 syn region	vimGlobal	matchgroup=Statement start='\<g\%[lobal]!\=/'  skip='\\.' end='/'	skipwhite nextgroup=vimSubst
    1              0.000015 syn region	vimGlobal	matchgroup=Statement start='\<v\%[global]!\=/' skip='\\.' end='/'	skipwhite nextgroup=vimSubst
                            
                            " Scripts  : perl,ruby : Benoit Cerrina {{{2
                            " =======    python,tcl: Johannes Zellner
                            "            lua
                            
                            " Allows users to specify the type of embedded script highlighting
                            " they want:  (perl/python/ruby/tcl support)
                            "   g:vimsyn_embed == 0   : don't embed any scripts
                            "   g:vimsyn_embed =~# 'l' : embed lua
                            "   g:vimsyn_embed =~# 'm' : embed mzscheme
                            "   g:vimsyn_embed =~# 'p' : embed perl
                            "   g:vimsyn_embed =~# 'P' : embed python
                            "   g:vimsyn_embed =~# 'r' : embed ruby
                            "   g:vimsyn_embed =~# 't' : embed tcl
    1              0.000005 if !exists("g:vimsyn_embed")
                             let g:vimsyn_embed= 0
                            endif
                            
                            " [-- lua --] {{{3
    1              0.000024 let s:luapath= fnameescape(expand("<sfile>:p:h")."/lua.vim")
    1              0.000023 if !filereadable(s:luapath)
                             for s:luapath in split(globpath(&rtp,"syntax/lua.vim"),"\n")
                              if filereadable(fnameescape(s:luapath))
                               let s:luapath= fnameescape(s:luapath)
                               break
                              endif
                             endfor
                            endif
    1              0.000005 if g:vimsyn_embed =~# 'l' && filereadable(s:luapath)
                             unlet! b:current_syntax
                             exe "syn include @vimLuaScript ".s:luapath
                             VimFoldl syn region vimLuaRegion matchgroup=vimScriptDelim start=+lua\s*<<\s*\z(.*\)$+ end=+^\z1$+	contains=@vimLuaScript
                             VimFoldl syn region vimLuaRegion matchgroup=vimScriptDelim start=+lua\s*<<\s*$+ end=+\.$+		contains=@vimLuaScript
                             syn cluster vimFuncBodyList	add=vimLuaRegion
                            else
    1              0.000011  syn region vimEmbedError start=+lua\s*<<\s*\z(.*\)$+ end=+^\z1$+
    1              0.000005  syn region vimEmbedError start=+lua\s*<<\s*$+ end=+\.$+
    1              0.000001 endif
    1              0.000002 unlet s:luapath
                            
                            " [-- perl --] {{{3
    1              0.000020 let s:perlpath= fnameescape(expand("<sfile>:p:h")."/perl.vim")
    1              0.000021 if !filereadable(s:perlpath)
                             for s:perlpath in split(globpath(&rtp,"syntax/perl.vim"),"\n")
                              if filereadable(fnameescape(s:perlpath))
                               let s:perlpath= fnameescape(s:perlpath)
                               break
                              endif
                             endfor
                            endif
    1              0.000005 if g:vimsyn_embed =~# 'p' && filereadable(s:perlpath)
                             unlet! b:current_syntax
                             let s:foldmethod = &l:foldmethod
                             exe "syn include @vimPerlScript ".s:perlpath
                             let &l:foldmethod = s:foldmethod
                             VimFoldp syn region vimPerlRegion  matchgroup=vimScriptDelim start=+pe\%[rl]\s*<<\s*\z(.*\)$+ end=+^\z1$+	contains=@vimPerlScript
                             VimFoldp syn region vimPerlRegion	matchgroup=vimScriptDelim start=+pe\%[rl]\s*<<\s*$+ end=+\.$+	contains=@vimPerlScript
                             syn cluster vimFuncBodyList	add=vimPerlRegion
                            else
    1              0.000010  syn region vimEmbedError start=+pe\%[rl]\s*<<\s*\z(.*\)$+ end=+^\z1$+
    1              0.000005  syn region vimEmbedError start=+pe\%[rl]\s*<<\s*$+ end=+\.$+
    1              0.000001 endif
    1              0.000001 unlet s:perlpath
                            
                            " [-- ruby --] {{{3
    1              0.000019 let s:rubypath= fnameescape(expand("<sfile>:p:h")."/ruby.vim")
    1              0.000020 if !filereadable(s:rubypath)
                             for s:rubypath in split(globpath(&rtp,"syntax/ruby.vim"),"\n")
                              if filereadable(fnameescape(s:rubypath))
                               let s:rubypath= fnameescape(s:rubypath)
                               break
                              endif
                             endfor
                            endif
    1              0.000004 if g:vimsyn_embed =~# 'r' && filereadable(s:rubypath)
                             unlet! b:current_syntax
                             let s:foldmethod = &l:foldmethod
                             exe "syn include @vimRubyScript ".s:rubypath
                             let &l:foldmethod = s:foldmethod
                             VimFoldr syn region vimRubyRegion matchgroup=vimScriptDelim start=+rub[y]\s*<<\s*\z(.*\)$+ end=+^\z1$+	contains=@vimRubyScript
                             syn region vimRubyRegion matchgroup=vimScriptDelim start=+rub[y]\s*<<\s*$+ end=+\.$+		contains=@vimRubyScript
                             syn cluster vimFuncBodyList	add=vimRubyRegion
                            else
    1              0.000005  syn region vimEmbedError start=+rub[y]\s*<<\s*\z(.*\)$+ end=+^\z1$+
    1              0.000004  syn region vimEmbedError start=+rub[y]\s*<<\s*$+ end=+\.$+
    1              0.000001 endif
    1              0.000001 unlet s:rubypath
                            
                            " [-- python --] {{{3
    1              0.000019 let s:pythonpath= fnameescape(expand("<sfile>:p:h")."/python.vim")
    1              0.000020 if !filereadable(s:pythonpath)
                             for s:pythonpath in split(globpath(&rtp,"syntax/python.vim"),"\n")
                              if filereadable(fnameescape(s:pythonpath))
                               let s:pythonpath= fnameescape(s:pythonpath)
                               break
                              endif
                             endfor
                            endif
    1              0.000007 if g:vimsyn_embed =~# 'P' && filereadable(s:pythonpath)
                             unlet! b:current_syntax
                             exe "syn include @vimPythonScript ".s:pythonpath
                             VimFoldP syn region vimPythonRegion matchgroup=vimScriptDelim start=+py\%[thon]3\=\s*<<\s*\z(.*\)$+ end=+^\z1$+	contains=@vimPythonScript
                             VimFoldP syn region vimPythonRegion matchgroup=vimScriptDelim start=+py\%[thon]3\=\s*<<\s*$+ end=+\.$+		contains=@vimPythonScript
                             VimFoldP syn region vimPythonRegion matchgroup=vimScriptDelim start=+Py\%[thon]2or3\s*<<\s*\z(.*\)$+ end=+^\z1$+		contains=@vimPythonScript
                             VimFoldP syn region vimPythonRegion matchgroup=vimScriptDelim start=+Py\%[thon]2or3\=\s*<<\s*$+ end=+\.$+		contains=@vimPythonScript
                             syn cluster vimFuncBodyList	add=vimPythonRegion
                            else
    1              0.000006  syn region vimEmbedError start=+py\%[thon]3\=\s*<<\s*\z(.*\)$+ end=+^\z1$+
    1              0.000004  syn region vimEmbedError start=+py\%[thon]3\=\s*<<\s*$+ end=+\.$+
    1              0.000001 endif
    1              0.000004 unlet s:pythonpath
                            
                            " [-- tcl --] {{{3
    1              0.000008 if has("win32") || has("win95") || has("win64") || has("win16")
                             " apparently has("tcl") has been hanging vim on some windows systems with cygwin
                             let s:trytcl= (&shell !~ '\<\%(bash\>\|4[nN][tT]\|\<zsh\)\>\%(\.exe\)\=$')
                            else
    1              0.000001  let s:trytcl= 1
    1              0.000001 endif
    1              0.000001 if s:trytcl
    1              0.000018  let s:tclpath= fnameescape(expand("<sfile>:p:h")."/tcl.vim")
    1              0.000020  if !filereadable(s:tclpath)
                              for s:tclpath in split(globpath(&rtp,"syntax/tcl.vim"),"\n")
                               if filereadable(fnameescape(s:tclpath))
                                let s:tclpath= fnameescape(s:tclpath)
                                break
                               endif
                              endfor
                             endif
    1              0.000004  if g:vimsyn_embed =~# 't' && filereadable(s:tclpath)
                              unlet! b:current_syntax
                              exe "syn include @vimTclScript ".s:tclpath
                              VimFoldt syn region vimTclRegion matchgroup=vimScriptDelim start=+tc[l]\=\s*<<\s*\z(.*\)$+ end=+^\z1$+	contains=@vimTclScript
                              VimFoldt syn region vimTclRegion matchgroup=vimScriptDelim start=+tc[l]\=\s*<<\s*$+ end=+\.$+	contains=@vimTclScript
                              syn cluster vimFuncBodyList	add=vimTclScript
                             else
    1              0.000006   syn region vimEmbedError start=+tc[l]\=\s*<<\s*\z(.*\)$+ end=+^\z1$+
    1              0.000004   syn region vimEmbedError start=+tc[l]\=\s*<<\s*$+ end=+\.$+
    1              0.000001  endif
    1              0.000001  unlet s:tclpath
    1              0.000001 else
                             syn region vimEmbedError start=+tc[l]\=\s*<<\s*\z(.*\)$+ end=+^\z1$+
                             syn region vimEmbedError start=+tc[l]\=\s*<<\s*$+ end=+\.$+
                            endif
    1              0.000001 unlet s:trytcl
                            
                            " [-- mzscheme --] {{{3
    1              0.000019 let s:mzschemepath= fnameescape(expand("<sfile>:p:h")."/scheme.vim")
    1              0.000020 if !filereadable(s:mzschemepath)
                             for s:mzschemepath in split(globpath(&rtp,"syntax/mzscheme.vim"),"\n")
                              if filereadable(fnameescape(s:mzschemepath))
                               let s:mzschemepath= fnameescape(s:mzschemepath)
                               break
                              endif
                             endfor
                            endif
    1              0.000004 if g:vimsyn_embed =~# 'm' && filereadable(s:mzschemepath)
                             unlet! b:current_syntax
                             let s:iskKeep= &isk
                             exe "syn include @vimMzSchemeScript ".s:mzschemepath
                             let &isk= s:iskKeep
                             unlet s:iskKeep
                             VimFoldm syn region vimMzSchemeRegion matchgroup=vimScriptDelim start=+mz\%[scheme]\s*<<\s*\z(.*\)$+ end=+^\z1$+	contains=@vimMzSchemeScript
                             VimFoldm syn region vimMzSchemeRegion matchgroup=vimScriptDelim start=+mz\%[scheme]\s*<<\s*$+ end=+\.$+		contains=@vimMzSchemeScript
                             syn cluster vimFuncBodyList	add=vimMzSchemeRegion
                            else
    1              0.000006  syn region vimEmbedError start=+mz\%[scheme]\s*<<\s*\z(.*\)$+ end=+^\z1$+
    1              0.000005  syn region vimEmbedError start=+mz\%[scheme]\s*<<\s*$+ end=+\.$+
    1              0.000001 endif
    1              0.000001 unlet s:mzschemepath
                            
                            " Synchronize (speed) {{{2
                            "============
    1              0.000002 if exists("g:vimsyn_minlines")
                             exe "syn sync minlines=".g:vimsyn_minlines
                            endif
    1              0.000005 exe "syn sync maxlines=".s:vimsyn_maxlines
    1              0.000003 syn sync linecont	"^\s\+\\"
    1              0.000010 syn sync match vimAugroupSyncA	groupthere NONE	"\<aug\%[roup]\>\s\+[eE][nN][dD]"
                            
                            " ====================
                            " Highlighting Settings {{{2
                            " ====================
                            
    1              0.000002 if !exists("skip_vim_syntax_inits")
    1              0.000002  if !exists("g:vimsyn_noerror")
    1              0.000006   hi def link vimBehaveError	vimError
    1              0.000002   hi def link vimCollClassErr	vimError
    1              0.000002   hi def link vimErrSetting	vimError
    1              0.000004   hi def link vimEmbedError	Normal
    1              0.000002   hi def link vimFTError	vimError
    1              0.000002   hi def link vimFunctionError	vimError
    1              0.000002   hi def link vimFunc         	vimError
    1              0.000001   hi def link vimHiAttribList	vimError
    1              0.000001   hi def link vimHiCtermError	vimError
    1              0.000001   hi def link vimHiKeyError	vimError
    1              0.000005   hi def link vimKeyCodeError	vimError
    1              0.000001   hi def link vimMapModErr	vimError
    1              0.000001   hi def link vimSubstFlagErr	vimError
    1              0.000001   hi def link vimSynCaseError	vimError
    1              0.000005   hi def link vimBufnrWarn	vimWarn
    1              0.000001  endif
                            
    1              0.000005  hi def link vimAbb	vimCommand
    1              0.000002  hi def link vimAddress	vimMark
    1              0.000002  hi def link vimAugroupError	vimError
    1              0.000007  hi def link vimAugroupKey	vimCommand
    1              0.000005  hi def link vimAuHighlight	vimHighlight
    1              0.000005  hi def link vimAutoCmdOpt	vimOption
    1              0.000005  hi def link vimAutoCmd	vimCommand
    1              0.000007  hi def link vimAutoEvent	Type
    1              0.000007  hi def link vimAutoSet	vimCommand
    1              0.000002  hi def link vimBehaveModel	vimBehave
    1              0.000004  hi def link vimBehave	vimCommand
    1              0.000007  hi def link vimBracket	Delimiter
    1              0.000005  hi def link vimCmplxRepeat	SpecialChar
    1              0.000007  hi def link vimCommand	Statement
    1              0.000005  hi def link vimComment	Comment
    1              0.000002  hi def link vimCommentString	vimString
    1              0.000007  hi def link vimCommentTitle	PreProc
    1              0.000007  hi def link vimCondHL	vimCommand
    1              0.000007  hi def link vimContinue	Special
    1              0.000004  hi def link vimCtrlChar	SpecialChar
    1              0.000004  hi def link vimEchoHLNone	vimGroup
    1              0.000004  hi def link vimEchoHL	vimCommand
    1              0.000004  hi def link vimElseIfErr	Error
    1              0.000004  hi def link vimElseif	vimCondHL
    1              0.000005  hi def link vimEnvvar	PreProc
    1              0.000004  hi def link vimError	Error
    1              0.000004  hi def link vimFBVar	vimVar
    1              0.000001  hi def link vimFgBgAttrib	vimHiAttrib
    1              0.000008  hi def link vimFold	Folded
    1              0.000005  hi def link vimFTCmd	vimCommand
    1              0.000004  hi def link vimFTOption	vimSynType
    1              0.000007  hi def link vimFuncKey	vimCommand
    1              0.000007  hi def link vimFuncName	Function
    1              0.000005  hi def link vimFuncSID	Special
    1              0.000007  hi def link vimFuncVar	Identifier
    1              0.000007  hi def link vimGroupAdd	vimSynOption
    1              0.000007  hi def link vimGroupName	vimGroup
    1              0.000001  hi def link vimGroupRem	vimSynOption
    1              0.000004  hi def link vimGroupSpecial	Special
    1              0.000007  hi def link vimGroup	Type
    1              0.000004  hi def link vimHiAttrib	PreProc
    1              0.000002  hi def link vimHiClear	vimHighlight
    1              0.000001  hi def link vimHiCtermFgBg	vimHiTerm
    1              0.000001  hi def link vimHiCTerm	vimHiTerm
    1              0.000004  hi def link vimHighlight	vimCommand
    1              0.000007  hi def link vimHiGroup	vimGroupName
    1              0.000001  hi def link vimHiGuiFgBg	vimHiTerm
    1              0.000001  hi def link vimHiGuiFont	vimHiTerm
    1              0.000002  hi def link vimHiGuiRgb	vimNumber
    1              0.000001  hi def link vimHiGui	vimHiTerm
    1              0.000004  hi def link vimHiNmbr	Number
    1              0.000001  hi def link vimHiStartStop	vimHiTerm
    1              0.000004  hi def link vimHiTerm	Type
    1              0.000004  hi def link vimHLGroup	vimGroup
    1              0.000007  hi def link vimHLMod	PreProc
    1              0.000002  hi def link vimInsert	vimString
    1              0.000004  hi def link vimIskSep	Delimiter
    1              0.000005  hi def link vimKeyCode	vimSpecFile
    1              0.000008  hi def link vimKeyword	Statement
    1              0.000007  hi def link vimLet	vimCommand
    1              0.000002  hi def link vimLineComment	vimComment
    1              0.000004  hi def link vimMapBang	vimCommand
    1              0.000004  hi def link vimMapModKey	vimFuncSID
    1              0.000004  hi def link vimMapMod	vimBracket
    1              0.000007  hi def link vimMap	vimCommand
    1              0.000005  hi def link vimMark	Number
    1              0.000002  hi def link vimMarkNumber	vimNumber
    1              0.000004  hi def link vimMenuMod	vimMapMod
    1              0.000002  hi def link vimMenuNameMore	vimMenuName
    1              0.000004  hi def link vimMenuName	PreProc
    1              0.000002  hi def link vimMtchComment	vimComment
    1              0.000004  hi def link vimNorm	vimCommand
    1              0.000007  hi def link vimNotation	Special
    1              0.000007  hi def link vimNotFunc	vimCommand
    1              0.000002  hi def link vimNotPatSep	vimString
    1              0.000005  hi def link vimNumber	Number
    1              0.000005  hi def link vimOperError	Error
    1              0.000007  hi def link vimOper	Operator
    1              0.000004  hi def link vimOption	PreProc
    1              0.000007  hi def link vimParenSep	Delimiter
    1              0.000002  hi def link vimPatSepErr	vimPatSep
    1              0.000002  hi def link vimPatSepR	vimPatSep
    1              0.000004  hi def link vimPatSep	SpecialChar
    1              0.000002  hi def link vimPatSepZone	vimString
    1              0.000002  hi def link vimPatSepZ	vimPatSep
    1              0.000004  hi def link vimPattern	Type
    1              0.000002  hi def link vimPlainMark	vimMark
    1              0.000002  hi def link vimPlainRegister	vimRegister
    1              0.000005  hi def link vimRegister	SpecialChar
    1              0.000008  hi def link vimScriptDelim	Comment
    1              0.000004  hi def link vimSearchDelim	Statement
    1              0.000002  hi def link vimSearch	vimString
    1              0.000004  hi def link vimSep	Delimiter
    1              0.000002  hi def link vimSetMod	vimOption
    1              0.000004  hi def link vimSetSep	Statement
    1              0.000002  hi def link vimSetString	vimString
    1              0.000005  hi def link vimSpecFile	Identifier
    1              0.000002  hi def link vimSpecFileMod	vimSpecFile
    1              0.000007  hi def link vimSpecial	Type
    1              0.000010  hi def link vimStatement	Statement
    1              0.000002  hi def link vimStringCont	vimString
    1              0.000005  hi def link vimString	String
    1              0.000002  hi def link vimSubst1	vimSubst
    1              0.000004  hi def link vimSubstDelim	Delimiter
    1              0.000004  hi def link vimSubstFlags	Special
    1              0.000004  hi def link vimSubstSubstr	SpecialChar
    1              0.000002  hi def link vimSubstTwoBS	vimString
    1              0.000005  hi def link vimSubst	vimCommand
    1              0.000004  hi def link vimSynCaseError	Error
    1              0.000004  hi def link vimSynCase	Type
    1              0.000004  hi def link vimSyncC	Type
    1              0.000004  hi def link vimSyncError	Error
    1              0.000004  hi def link vimSyncGroupName	vimGroupName
    1              0.000004  hi def link vimSyncGroup	vimGroupName
    1              0.000004  hi def link vimSyncKey	Type
    1              0.000004  hi def link vimSyncNone	Type
    1              0.000004  hi def link vimSynContains	vimSynOption
    1              0.000004  hi def link vimSynError	Error
    1              0.000004  hi def link vimSynKeyContainedin	vimSynContains
    1              0.000001  hi def link vimSynKeyOpt	vimSynOption
    1              0.000004  hi def link vimSynMtchGrp	vimSynOption
    1              0.000004  hi def link vimSynMtchOpt	vimSynOption
    1              0.000004  hi def link vimSynNextgroup	vimSynOption
    1              0.000002  hi def link vimSynNotPatRange	vimSynRegPat
    1              0.000004  hi def link vimSynOption	Special
    1              0.000002  hi def link vimSynPatRange	vimString
    1              0.000004  hi def link vimSynRegOpt	vimSynOption
    1              0.000002  hi def link vimSynRegPat	vimString
    1              0.000007  hi def link vimSynReg	Type
    1              0.000005  hi def link vimSyntax	vimCommand
    1              0.000004  hi def link vimSynType	vimSpecial
    1              0.000007  hi def link vimTodo	Todo
    1              0.000005  hi def link vimUnmap	vimMap
    1              0.000005  hi def link vimUserAttrbCmpltFunc	Special
    1              0.000002  hi def link vimUserAttrbCmplt	vimSpecial
    1              0.000002  hi def link vimUserAttrbKey	vimOption
    1              0.000001  hi def link vimUserAttrb	vimSpecial
    1              0.000005  hi def link vimUserAttrbError	Error
    1              0.000005  hi def link vimUserCmdError	Error
    1              0.000004  hi def link vimUserCommand	vimCommand
    1              0.000004  hi def link vimUserFunc	Normal
    1              0.000007  hi def link vimVar	Identifier
    1              0.000004  hi def link vimWarn	WarningMsg
                            
    1              0.000004  hi def link nvimAutoEvent	vimAutoEvent
    1              0.000002  hi def link nvimHLGroup	vimHLGroup
    1              0.000004  hi def link nvimMap	vimMap
    1              0.000002  hi def link nvimUnmap	vimUnmap
    1              0.000001 endif
                            
                            " Current Syntax Variable: {{{2
    1              0.000002 let b:current_syntax = "vim"
                            
                            " ---------------------------------------------------------------------
                            " Cleanup: {{{1
    1              0.000002 delc VimFolda
    1              0.000001 delc VimFoldf
    1              0.000001 delc VimFoldl
    1              0.000001 delc VimFoldm
    1              0.000001 delc VimFoldp
    1              0.000001 delc VimFoldP
    1              0.000001 delc VimFoldr
    1              0.000001 delc VimFoldt
    1              0.000008 let &cpo = s:keepcpo
    1              0.000001 unlet s:keepcpo
                            " vim:ts=18  fdm=marker

SCRIPT  /usr/local/Cellar/neovim/0.2.2_1/share/nvim/runtime/syntax/vim/generated.vim
Sourced 1 time
Total time:   0.002008
 Self time:   0.002008

count  total (s)   self (s)
    1              0.001096 syn keyword vimCommand contained  a[ppend] ab[breviate] abc[lear] abo[veleft] al[l] am[enu] an[oremenu] ar[gs] arga[dd] argd[elete] argdo arge[dit] argg[lobal] argl[ocal] argu[ment] as[cii] au[tocmd] aug[roup] aun[menu] b[uffer] bN[ext] ba[ll] bad[d] bd[elete] be[have] bel[owright] bf[irst] bl[ast] bm[odified] bn[ext] bo[tright] bp[revious] br[ewind] brea[k] breaka[dd] breakd[el] breakl[ist] bro[wse] bu[ffers] bufd[o] bun[load] bw[ipeout] c[hange] cN[ext] cNf[ile] ca[bbrev] cabc[lear] cad[dbuffer] cadde[xpr] caddf[ile] cal[l] cat[ch] cb[uffer] cbo[ttom] cc ccl[ose] cd cdo ce[nter] cex[pr] cf[ile] cfd[o] cfi[rst] cg[etfile] cgetb[uffer] cgete[xpr] ch[dir] cha[nges] che[ckhealth] checkp[ath] checkt[ime] chi[story] cl[ist] cla[st] clo[se] cle[arjumps] cm[ap] cmapc[lear] cme[nu] cn[ext] cnew[er] cnf[ile] cno[remap] cnorea[bbrev] cnorem[enu] co[py]
    1              0.000074 syn keyword vimCommand contained  col[der] colo[rscheme] com[mand] comc[lear] comp[iler] con[tinue] conf[irm] cop[en] cp[revious] cpf[ile] cq[uit] cr[ewind] cs[cope] cst[ag] cu[nmap] cuna[bbrev] cunm[enu] cw[indow] d[elete] delm[arks] deb[ug] debugg[reedy] del[command] delf[unction] di[splay] dif[fupdate] diffg[et] diffo[ff] diffp[atch] diffpu[t] diffs[plit] difft[his] dig[raphs] dj[ump] dl[ist] do[autocmd] doautoa[ll] dr[op] ds[earch] dsp[lit] e[dit] ea[rlier] ec[ho] echoe[rr] echoh[l] echom[sg] echon el[se] elsei[f] em[enu] en[dif] endf[unction] endfo[r] endt[ry] endw[hile] ene[w] ex exe[cute] exi[t] exu[sage] f[ile] files filet[ype] filt[er] fin[d] fina[lly] fini[sh] fir[st] fo[ld] foldc[lose] foldd[oopen] folddoc[losed] foldo[pen] for fu[nction] g[lobal] go[to] gr[ep] grepa[dd] gu[i] gv[im] h[elp] helpc[lose] helpg[rep] helpt[ags] ha[rdcopy]
    1              0.000063 syn keyword vimCommand contained  hi[ghlight] hid[e] his[tory] i[nsert] ia[bbrev] iabc[lear] if ij[ump] il[ist] im[ap] imapc[lear] ime[nu] in[oremap] inorea[bbrev] inorem[enu] int[ro] is[earch] isp[lit] iu[nmap] iuna[bbrev] iunm[enu] j[oin] ju[mps] k ke[epmarks] keepj[umps] keepp[atterns] keepa[lt] l[ist] lN[ext] lNf[ile] la[st] lan[guage] lad[dexpr] laddb[uffer] laddf[ile] lat[er] lb[uffer] lbo[ttom] lc[d] lch[dir] lcl[ose] lcs[cope] ld[o] le[ft] lefta[bove] let lex[pr] lf[ile] lfd[o] lfi[rst] lg[etfile] lgetb[uffer] lgete[xpr] lgr[ep] lgrepa[dd] lh[elpgrep] lhi[story] ll lla[st] lli[st] lm[ap] lmapc[lear] lmak[e] ln[oremap] lne[xt] lnew[er] lnf[ile] lo[adview] loadk[eymap] loc[kmarks] lockv[ar] lol[der] lop[en] lp[revious] lpf[ile] lr[ewind] lt[ag] lu[nmap] lua luad[o] luaf[ile] lv[imgrep] lvimgrepa[dd] lw[indow] ls m[ove] ma[rk] mak[e] map
    1              0.000063 syn keyword vimCommand contained  mapc[lear] mar[ks] mat[ch] me[nu] menut[ranslate] mes[sages] mk[exrc] mks[ession] mksp[ell] mkv[imrc] mkvie[w] mo[de] mz[scheme] mzf[ile] n[ext] nb[key] nbc[lose] nbs[tart] ne[w] nm[ap] nmapc[lear] nme[nu] nn[oremap] nnoreme[nu] no[remap] noa[utocmd] noh[lsearch] nor[eabbrev] norem[enu] nos[wapfile] nor[mal] nu[mber] nun[map] nunme[nu] o[ldfiles] om[ap] omapc[lear] ome[nu] on[ly] ono[remap] onoreme[nu] op[tions] ou[nmap] ounme[nu] ow[nsyntax] p[rint] pa[ckadd] packl[oadall] pc[lose] pe[rl] perld[o] ped[it] po[p] popu[p] pp[op] pr[eserve] prev[ious] pro[mptfind] promptr[epl] prof[ile] profd[el] ps[earch] pt[ag] ptN[ext] ptf[irst] ptj[ump] ptl[ast] ptn[ext] ptp[revious] ptr[ewind] pts[elect] pu[t] pw[d] py[thon] pyd[o] pyf[ile] py3 py3d[o] pyt[hon3] py3[file] q[uit] quita[ll] qa[ll] r[ead] rec[over] red[o] redi[r]
    1              0.000065 syn keyword vimCommand contained  redr[aw] redraws[tatus] reg[isters] res[ize] ret[ab] retu[rn] rew[ind] ri[ght] rightb[elow] rs[hada] ru[ntime] rund[o] rub[y] rubyd[o] rubyf[ile] rv[iminfo] s[ubstitute] sN[ext] sa[rgument] sal[l] san[dbox] sav[eas] sb[uffer] sbN[ext] sba[ll] sbf[irst] sbl[ast] sbm[odified] sbn[ext] sbp[revious] sbr[ewind] sc[riptnames] scripte[ncoding] scs[cope] se[t] setf[iletype] setg[lobal] setl[ocal] sf[ind] sfir[st] si[malt] sig[n] sil[ent] sl[eep] sla[st] sm[agic] smap smapc[lear] sme[nu] sn[ext] sno[magic] snor[emap] snoreme[nu] so[urce] sor[t] sp[lit] spe[llgood] spelld[ump] spelli[nfo] spellr[epall] spellu[ndo] spellw[rong] spr[evious] sr[ewind] st[op] sta[g] star[tinsert] startg[replace] startr[eplace] sto[pinsert] stj[ump] sts[elect] su[nhide] sunm[ap] sunme[nu] sus[pend] sv[iew] sw[apname] sy[ntax] synti[me] sync[bind]
    1              0.000064 syn keyword vimCommand contained  t tc[d] tch[dir] tN[ext] ta[g] tags tab tabc[lose] tabd[o] tabe[dit] tabf[ind] tabfir[st] tabm[ove] tabl[ast] tabn[ext] tabnew tabo[nly] tabp[revious] tabN[ext] tabr[ewind] tabs tc[l] tcld[o] tclf[ile] te[rminal] tf[irst] th[row] tj[ump] tl[ast] tm[ap] tmapc[lear] tme[nu] tn[ext] tno[remap] to[pleft] tp[revious] tr[ewind] try ts[elect] tu[nmap] tunme[nu] u[ndo] undoj[oin] undol[ist] una[bbreviate] unh[ide] unl[et] unlo[ckvar] unm[ap] unme[nu] uns[ilent] up[date] v[global] ve[rsion] verb[ose] vert[ical] vi[sual] vie[w] vim[grep] vimgrepa[dd] viu[sage] vm[ap] vmapc[lear] vme[nu] vn[oremap] vne[w] vno[remenu] vs[plit] vu[nmap] vunme[nu] w[rite] wN[ext] wa[ll] wh[ile] wi[nsize] winc[md] wind[o] winp[os] wn[ext] wp[revious] wq wqa[ll] ws[verb] wsh[ada] wu[ndo] wv[iminfo] x[it] xa[ll] xm[ap] xmapc[lear] xme[nu] xn[oremap]
    1              0.000008 syn keyword vimCommand contained  xnoreme[nu] xu[nmap] xunme[nu] y[ank] N[ext]
                            
    1              0.000023 syn keyword vimOption contained  aleph al arabic arab invarabic noarabic invarab noarab arabicshape arshape invarabicshape noarabicshape invarshape noarshape allowrevins ari invallowrevins noallowrevins invari noari altkeymap akm invaltkeymap noaltkeymap invakm noakm ambiwidth ambw autochdir acd invautochdir noautochdir invacd noacd autoindent ai invautoindent noautoindent invai noai autoread ar invautoread noautoread invar noar autowrite aw invautowrite noautowrite invaw noaw autowriteall awa invautowriteall noautowriteall invawa noawa background bg backspace bs backup bk invbackup nobackup invbk nobk backupcopy bkc backupdir bdir backupext bex backupskip bsk belloff bo binary bin invbinary nobinary invbin nobin bomb invbomb nobomb breakat brk breakindent bri invbreakindent nobreakindent invbri nobri breakindentopt briopt browsedir bsdir bufhidden bh
    1              0.000026 syn keyword vimOption contained  buflisted bl invbuflisted nobuflisted invbl nobl buftype bt casemap cmp cdpath cd cedit charconvert ccv cindent cin invcindent nocindent invcin nocin cinkeys cink cinoptions cino cinwords cinw clipboard cb cmdheight ch cmdwinheight cwh colorcolumn cc columns co comments com commentstring cms complete cpt concealcursor cocu conceallevel cole completefunc cfu completeopt cot confirm cf invconfirm noconfirm invcf nocf copyindent ci invcopyindent nocopyindent invci noci cpoptions cpo cscopepathcomp cspc cscopeprg csprg cscopequickfix csqf cscoperelative csre invcscoperelative nocscoperelative invcsre nocsre cscopetag cst invcscopetag nocscopetag invcst nocst cscopetagorder csto cscopeverbose csverb invcscopeverbose nocscopeverbose invcsverb nocsverb cursorbind crb invcursorbind nocursorbind invcrb nocrb cursorcolumn cuc invcursorcolumn nocursorcolumn invcuc nocuc
    1              0.000127 syn keyword vimOption contained  cursorline cul invcursorline nocursorline invcul nocul debug define def delcombine deco invdelcombine nodelcombine invdeco nodeco dictionary dict diff invdiff nodiff diffexpr dex diffopt dip digraph dg invdigraph nodigraph invdg nodg directory dir display dy eadirection ead emoji emo invemoji noemoji invemo noemo encoding enc endofline eol invendofline noendofline inveol noeol equalalways ea invequalalways noequalalways invea noea equalprg ep errorbells eb inverrorbells noerrorbells inveb noeb errorfile ef errorformat efm eventignore ei expandtab et invexpandtab noexpandtab invet noet exrc ex invexrc noexrc invex noex fileencoding fenc fileencodings fencs fileformat ff fileformats ffs fileignorecase fic invfileignorecase nofileignorecase invfic nofic filetype ft fillchars fcs fixendofline fixeol invfixendofline nofixendofline invfixeol nofixeol
    1              0.000025 syn keyword vimOption contained  fkmap fk invfkmap nofkmap invfk nofk foldclose fcl foldcolumn fdc foldenable fen invfoldenable nofoldenable invfen nofen foldexpr fde foldignore fdi foldlevel fdl foldlevelstart fdls foldmarker fmr foldmethod fdm foldminlines fml foldnestmax fdn foldopen fdo foldtext fdt formatexpr fex formatoptions fo formatlistpat flp formatprg fp fsync fs invfsync nofsync invfs nofs gdefault gd invgdefault nogdefault invgd nogd grepformat gfm grepprg gp guicursor gcr guifont gfn guifontset gfs guifontwide gfw guioptions go guitablabel gtl guitabtooltip gtt helpfile hf helpheight hh helplang hlg hidden hid invhidden nohidden invhid nohid highlight hl history hi hkmap hk invhkmap nohkmap invhk nohk hkmapp hkp invhkmapp nohkmapp invhkp nohkp hlsearch hls invhlsearch nohlsearch invhls nohls icon invicon noicon iconstring ignorecase ic invignorecase noignorecase invic noic
    1              0.000023 syn keyword vimOption contained  imcmdline imc invimcmdline noimcmdline invimc noimc imdisable imd invimdisable noimdisable invimd noimd iminsert imi imsearch ims inccommand icm include inc includeexpr inex incsearch is invincsearch noincsearch invis nois indentexpr inde indentkeys indk infercase inf invinfercase noinfercase invinf noinf insertmode im invinsertmode noinsertmode invim noim isfname isf isident isi iskeyword isk isprint isp joinspaces js invjoinspaces nojoinspaces invjs nojs keymap kmp keymodel km keywordprg kp langmap lmap langmenu lm langnoremap lnr invlangnoremap nolangnoremap invlnr nolnr langremap lrm invlangremap nolangremap invlrm nolrm laststatus ls lazyredraw lz invlazyredraw nolazyredraw invlz nolz linebreak lbr invlinebreak nolinebreak invlbr nolbr lines linespace lsp lisp invlisp nolisp lispwords lw list invlist nolist
    1              0.000022 syn keyword vimOption contained  listchars lcs loadplugins lpl invloadplugins noloadplugins invlpl nolpl magic invmagic nomagic makeef mef makeprg mp matchpairs mps matchtime mat maxcombine mco maxfuncdepth mfd maxmapdepth mmd maxmem mm maxmempattern mmp maxmemtot mmt menuitems mis mkspellmem msm modeline ml invmodeline nomodeline invml noml modelines mls modifiable ma invmodifiable nomodifiable invma noma modified mod invmodified nomodified invmod nomod more invmore nomore mouse mousefocus mousef invmousefocus nomousefocus invmousef nomousef mousehide mh invmousehide nomousehide invmh nomh mousemodel mousem mouseshape mouses mousetime mouset nrformats nf number nu invnumber nonumber invnu nonu numberwidth nuw omnifunc ofu opendevice odev invopendevice noopendevice invodev noodev operatorfunc opfunc packpath pp paragraphs para paste invpaste nopaste
    1              0.000020 syn keyword vimOption contained  pastetoggle pt patchexpr pex patchmode pm path pa preserveindent pi invpreserveindent nopreserveindent invpi nopi previewheight pvh previewwindow pvw invpreviewwindow nopreviewwindow invpvw nopvw printdevice pdev printencoding penc printexpr pexpr printfont pfn printheader pheader printmbcharset pmbcs printmbfont pmbfn printoptions popt prompt invprompt noprompt pumheight ph quoteescape qe readonly ro invreadonly noreadonly invro noro redrawtime rdt regexpengine re relativenumber rnu invrelativenumber norelativenumber invrnu nornu remap invremap noremap report revins ri invrevins norevins invri nori rightleft rl invrightleft norightleft invrl norl rightleftcmd rlc ruler ru invruler noruler invru noru rulerformat ruf runtimepath rtp scroll scr scrollback scbk scrollbind scb invscrollbind noscrollbind invscb noscb
    1              0.000025 syn keyword vimOption contained  scrolljump sj scrolloff so scrollopt sbo sections sect secure invsecure nosecure selection sel selectmode slm sessionoptions ssop shada sd shell sh shellcmdflag shcf shellpipe sp shellquote shq shellredir srr shellslash ssl invshellslash noshellslash invssl nossl shelltemp stmp invshelltemp noshelltemp invstmp nostmp shellxquote sxq shellxescape sxe shiftround sr invshiftround noshiftround invsr nosr shiftwidth sw shortmess shm showbreak sbr showcmd sc invshowcmd noshowcmd invsc nosc showfulltag sft invshowfulltag noshowfulltag invsft nosft showmatch sm invshowmatch noshowmatch invsm nosm showmode smd invshowmode noshowmode invsmd nosmd showtabline stal sidescroll ss sidescrolloff siso signcolumn scl smartcase scs invsmartcase nosmartcase invscs noscs smartindent si invsmartindent nosmartindent invsi nosi smarttab sta invsmarttab nosmarttab invsta nosta
    1              0.000024 syn keyword vimOption contained  softtabstop sts spell invspell nospell spellcapcheck spc spellfile spf spelllang spl spellsuggest sps splitbelow sb invsplitbelow nosplitbelow invsb nosb splitright spr invsplitright nosplitright invspr nospr startofline sol invstartofline nostartofline invsol nosol statusline stl suffixes su suffixesadd sua swapfile swf invswapfile noswapfile invswf noswf switchbuf swb synmaxcol smc syntax syn tabline tal tabpagemax tpm tabstop ts tagbsearch tbs invtagbsearch notagbsearch invtbs notbs tagcase tc taglength tl tagrelative tr invtagrelative notagrelative invtr notr tags tag tagstack tgst invtagstack notagstack invtgst notgst termbidi tbidi invtermbidi notermbidi invtbidi notbidi termencoding tenc termguicolors tgc invtermguicolors notermguicolors invtgc notgc terse invterse noterse textwidth tw thesaurus tsr tildeop top invtildeop notildeop invtop notop
    1              0.000020 syn keyword vimOption contained  timeout to invtimeout notimeout invto noto timeoutlen tm title invtitle notitle titlelen titleold titlestring ttimeout invttimeout nottimeout ttimeoutlen ttm undodir udir undofile udf invundofile noundofile invudf noudf undolevels ul undoreload ur updatecount uc updatetime ut verbose vbs verbosefile vfile viewdir vdir viewoptions vop viminfo vi virtualedit ve visualbell vb invvisualbell novisualbell invvb novb warn invwarn nowarn whichwrap ww wildchar wc wildcharm wcm wildignore wig wildignorecase wic invwildignorecase nowildignorecase invwic nowic wildmenu wmnu invwildmenu nowildmenu invwmnu nowmnu wildmode wim wildoptions wop winaltkeys wak winhighlight winhl window wi winheight wh winfixheight wfh invwinfixheight nowinfixheight invwfh nowfh winfixwidth wfw invwinfixwidth nowinfixwidth invwfw nowfw winminheight wmh
    1              0.000007 syn keyword vimOption contained  winminwidth wmw winwidth wiw wrap invwrap nowrap wrapmargin wm wrapscan ws invwrapscan nowrapscan invws nows write invwrite nowrite writeany wa invwriteany nowriteany invwa nowa writebackup wb invwritebackup nowritebackup invwb nowb writedelay wd
                            
    1              0.000001 syn case ignore
                            
    1              0.000053 syn keyword vimAutoEvent contained  BufAdd BufDelete BufEnter BufFilePost BufFilePre BufHidden BufLeave BufNew BufNewFile BufReadCmd BufReadPost BufReadPre BufUnload BufWinEnter BufWinLeave BufWipeout BufWriteCmd BufWritePost BufWritePre CmdUndefined CmdWinEnter CmdWinLeave ColorScheme CompleteDone CursorHold CursorHoldI CursorMoved CursorMovedI EncodingChanged FileAppendCmd FileAppendPost FileAppendPre FileChangedRO FileChangedShell FileChangedShellPost FileReadCmd FileReadPost FileReadPre FileType FileWriteCmd FileWritePost FileWritePre FilterReadPost FilterReadPre FilterWritePost FilterWritePre FocusGained FocusLost FuncUndefined GUIEnter GUIFailed InsertChange InsertCharPre InsertEnter InsertLeave JobActivity MenuPopup OptionSet QuickFixCmdPost QuickFixCmdPre QuitPre RemoteReply SessionLoadPost ShellCmdPost ShellFilterPost SourceCmd SourcePre
    1              0.000013 syn keyword vimAutoEvent contained  SpellFileMissing StdinReadPost StdinReadPre SwapExists Syntax TabEnter TabLeave TermChanged TermResponse TextChanged TextChangedI TextYankPost User VimEnter VimLeave VimLeavePre VimResized WinNew WinEnter WinLeave BufWrite FileEncoding BufCreate BufRead
                            
    1              0.000004 syn keyword nvimAutoEvent contained  TabNewEntered TabClosed TabNew TermOpen TermClose DirChanged
                            
    1              0.000001 syn case match
                            
    1              0.000022 syn keyword vimFuncName contained  ceil nvim_win_get_position lispindent nvim_buf_line_count strftime sinh nvim_tabpage_get_win inputdialog shellescape settabwinvar tagfiles append getwinposx msgpackparse tabpagewinnr jobclose nvim_set_current_tabpage map settabvar nvim_buf_get_changedtick inputlist has_key resolve inputsave strcharpart libcallnr nvim_win_set_cursor range sqrt setbufvar winheight dictwatcheradd gettabvar getcmdline setwinvar assert_match float2nr expand setline delete round nvim_get_color_by_name dictwatcherdel funcref win_findbuf nvim__id_float rpcstop hasmapto rpcnotify atan2 nvim_feedkeys indent reverse timer_stopall screenchar setcharsearch serverstart nvim_win_set_var jobpid nvim_get_vvar asin nvim_get_hl_by_name sort winbufnr garbagecollect diff_filler nvim_tabpage_get_var char2nr getpid maparg foreground setfperm histadd
    1              0.000023 syn keyword vimFuncName contained  str2nr strridx invert foldclosedend pumvisible getcompletion extend serverstop min fmod nextnonblank nvim__id_array assert_fails nvim_set_current_dir sin bufloaded setloclist nvim_win_get_option atan changenr setreg nvim_win_get_height nvim_list_tabpages line2byte nvim_get_current_win assert_inrange setqflist nvim_list_runtime_paths getloclist buffer_exists getcmdwintype writefile glob2regpat nvim_get_current_line nvim_input serverlist nvim_set_var winwidth getwininfo cosh nvim_tabpage_is_valid nvim_set_option has inputrestore argc exp nvim_buf_add_highlight json_encode match nvim_buf_get_lines nvim_replace_termcodes execute nvim_command_output getregtype nr2char getline nvim_buf_del_var islocked screencol getcharsearch getftype abs timer_stop reltimestr reltimefloat getfsize last_buffer_nr inputsecret nvim_tabpage_list_wins
    1              0.000022 syn keyword vimFuncName contained  nvim_tabpage_set_var escape getcmdpos readfile screenattr hlID nvim_tabpage_del_var nvim_tabpage_get_number nvim_get_hl_by_id getwinvar rpcrequest getwinposy iconv matcharg nvim_win_get_number nvim_err_writeln matchstr buflisted nvim_err_write assert_equal index haslocaldir nvim_win_get_var searchpair nvim_del_var complete rename join mkdir sockconnect globpath getqflist copy strchars log nvim_command winnr screenrow jobresize nvim_buf_set_lines nvim_buf_get_number strpart getreg eval localtime matchstrpos setcmdpos clearmatches repeat nvim_win_del_var cursor getcurpos highlight_exists filereadable assert_notmatch str2float bufwinid gettabwinvar gettabinfo bufexists insert nvim_buf_get_name pow count or assert_exception foldlevel hostname browse getchar undofile synIDattr getmatches feedkeys function strgetchar
    1              0.000024 syn keyword vimFuncName contained  getbufline nvim_eval nvim_set_current_win tabpagebuflist nvim__id log10 winline histnr winsaveview finddir searchpairpos winrestview system acos confirm foldclosed simplify call arglistid nvim_win_is_valid getcharmod argv matchadd json_decode values highlightID exepath reltime strtrans trunc col menu_get tr file_readable nvim_strwidth matchlist assert_true searchdecl isdirectory cos filewritable nvim_call_function cindent tan msgpackdump pathshorten matchaddpos printf sha256 spellbadword jobstop fnamemodify win_id2win byteidx wordcount pyeval nvim_win_set_width diff_hlID libcall remove bufname taglist tabpagenr foldtext get foldtextresult mode and complete_check assert_false rpcstart win_id2tabwin keys line hlexists bufwinnr tolower mapcheck strwidth getcwd setpos fnameescape items synID getftime jobsend tempname
    1              0.000021 syn keyword vimFuncName contained  nvim_win_get_cursor search histget wildmenumode strdisplaywidth spellsuggest nvim_get_option nvim_get_color_map undotree nvim_list_bufs input getbufinfo complete_add strlen eventhandler matchdelete stridx prevnonblank browsedir buffer_name exists win_gotoid soundfold did_filetype nvim_buf_get_mark getfperm nvim_buf_get_var jobwait wincol synIDtrans synconcealed bufnr nvim_buf_get_option matchend filter tanh visualmode string test_garbagecollect_now executable timer_pause timer_start findfile toupper nvim_get_keymap setmatches nvim__id_dictionary nvim_buf_set_option nvim_out_write uniq nvim_del_current_line timer_info virtcol win_getid py3eval nvim_win_set_height nvim_win_get_buf nvim_get_current_tabpage substitute assert_report synstack api_info nvim_list_wins nvim_set_current_buf glob nvim_win_get_width nvim_get_current_buf
    1              0.000017 syn keyword vimFuncName contained  nvim_win_get_tabpage byte2line empty nvim_get_mode searchpos submatch getcmdtype nvim_buf_is_valid buffer_number split id jobstart len cscope_connection luaeval nvim_get_var nvim_set_current_line argidx assert_notequal winrestcmd add floor getpos max getfontname nvim_buf_clear_highlight getbufvar nvim_buf_set_name termopen shiftwidth byteidxcomp systemlist nvim_buf_set_var nvim_buf_get_keymap nvim_win_set_option deepcopy xor type histdel

SCRIPT  /usr/local/Cellar/neovim/0.2.2_1/share/nvim/runtime/autoload/provider/python.vim
Sourced 1 time
Total time:   0.488139
 Self time:   0.000739

count  total (s)   self (s)
                            " The Python provider uses a Python host to emulate an environment for running
                            " python-vim plugins. :help provider
                            "
                            " Associating the plugin with the Python host is the first step because plugins
                            " will be passed as command-line arguments
                            
    1              0.000004 if exists('g:loaded_python_provider')
                              finish
                            endif
    1              0.000005 let g:loaded_python_provider = 1
                            
    1   0.487865   0.000560 let [s:prog, s:err] = provider#pythonx#Detect(2)
                            
    1              0.000004 function! provider#python#Prog()
                              return s:prog
                            endfunction
                            
    1              0.000002 function! provider#python#Error()
                              return s:err
                            endfunction
                            
    1              0.000002 if s:prog == ''
                              " Detection failed
                              finish
                            endif
                            
                            " The Python provider plugin will run in a separate instance of the Python
                            " host.
    1   0.000039   0.000017 call remote#host#RegisterClone('legacy-python-provider', 'python')
    1   0.000086   0.000012 call remote#host#RegisterPlugin('legacy-python-provider', 'script_host.py', [])
                            
    1              0.000002 function! provider#python#Call(method, args)
                              if s:err != ''
                                return
                              endif
                              if !exists('s:host')
                                let s:rpcrequest = function('rpcrequest')
                            
                                " Ensure that we can load the Python host before bootstrapping
                                try
                                  let s:host = remote#host#Require('legacy-python-provider')
                                catch
                                  let s:err = v:exception
                                  echohl WarningMsg
                                  echomsg v:exception
                                  echohl None
                                  return
                                endtry
                              endif
                              return call(s:rpcrequest, insert(insert(a:args, 'python_'.a:method), s:host))
                            endfunction

SCRIPT  /usr/local/Cellar/neovim/0.2.2_1/share/nvim/runtime/autoload/provider/pythonx.vim
Sourced 1 time
Total time:   0.000186
 Self time:   0.000186

count  total (s)   self (s)
                            " The Python provider helper
    1              0.000005 if exists('s:loaded_pythonx_provider')
                              finish
                            endif
                            
    1              0.000003 let s:loaded_pythonx_provider = 1
                            
    1              0.000012 let s:job_opts = {'rpc': v:true, 'on_stderr': function('provider#stderr_collector')}
                            
    1              0.000004 function! provider#pythonx#Require(host) abort
                              let ver = (a:host.orig_name ==# 'python') ? 2 : 3
                            
                              " Python host arguments
                              let prog = (ver == '2' ?  provider#python#Prog() : provider#python3#Prog())
                              let args = [prog, '-c', 'import sys; sys.path.remove(""); import neovim; neovim.start_host()']
                            
                              " Collect registered Python plugins into args
                              let python_plugins = remote#host#PluginsForHost(a:host.name)
                              for plugin in python_plugins
                                call add(args, plugin.path)
                              endfor
                            
                              try
                                let channel_id = jobstart(args, s:job_opts)
                                if rpcrequest(channel_id, 'poll') ==# 'ok'
                                  return channel_id
                                endif
                              catch
                                echomsg v:throwpoint
                                echomsg v:exception
                                for row in provider#get_stderr(channel_id)
                                  echomsg row
                                endfor
                              finally
                                call provider#clear_stderr(channel_id)
                              endtry
                              throw remote#host#LoadErrorForHost(a:host.orig_name,
                                    \ '$NVIM_PYTHON_LOG_FILE')
                            endfunction
                            
    1              0.000003 function! provider#pythonx#Detect(major_ver) abort
                              if a:major_ver == 2
                                if exists('g:python_host_prog')
                                  return [g:python_host_prog, '']
                                else
                                  let progs = ['python2', 'python2.7', 'python2.6', 'python']
                                endif
                              else
                                if exists('g:python3_host_prog')
                                  return [g:python3_host_prog, '']
                                else
                                  let progs = ['python3', 'python3.7', 'python3.6', 'python3.5',
                                        \ 'python3.4', 'python3.3', 'python']
                                endif
                              endif
                            
                              let errors = []
                            
                              for prog in progs
                                let [result, err] = s:check_interpreter(prog, a:major_ver)
                                if result
                                  return [prog, err]
                                endif
                                " Accumulate errors in case we don't find
                                " any suitable Python interpreter.
                                call add(errors, err)
                              endfor
                            
                              " No suitable Python interpreter found.
                              return ['', 'provider/pythonx: Could not load Python ' . a:major_ver
                                    \ . ":\n" .  join(errors, "\n")]
                            endfunction
                            
    1              0.000004 function! s:check_interpreter(prog, major_ver) abort
                              let prog_path = exepath(a:prog)
                              if prog_path ==# ''
                                return [0, a:prog . ' not found in search path or not executable.']
                              endif
                            
                              let min_version = (a:major_ver == 2) ? '2.6' : '3.3'
                            
                              " Try to load neovim module, and output Python version.
                              " Return codes:
                              "   0  Neovim module can be loaded.
                              "   2  Neovim module cannot be loaded.
                              "   Otherwise something else went wrong (e.g. 1 or 127).
                              let prog_ver = system([ a:prog , '-c' ,
                                    \ 'import sys; ' .
                                    \ 'sys.path.remove(""); ' .
                                    \ 'sys.stdout.write(str(sys.version_info[0]) + "." + str(sys.version_info[1])); ' .
                                    \ 'import pkgutil; ' .
                                    \ 'exit(2*int(pkgutil.get_loader("neovim") is None))'
                                    \ ])
                            
                              if v:shell_error == 2 || v:shell_error == 0
                                " Check version only for expected return codes.
                                if prog_ver !~ '^' . a:major_ver
                                  return [0, prog_path . ' is Python ' . prog_ver . ' and cannot provide Python '
                                        \ . a:major_ver . '.']
                                elseif prog_ver =~ '^' . a:major_ver && prog_ver < min_version
                                  return [0, prog_path . ' is Python ' . prog_ver . ' and cannot provide Python >= '
                                        \ . min_version . '.']
                                endif
                              endif
                            
                              if v:shell_error == 2
                                return [0, prog_path.' does not have the "neovim" module. :help provider-python']
                              elseif v:shell_error == 127
                                " This can happen with pyenv's shims.
                                return [0, prog_path . ' does not exist: ' . prog_ver]
                              elseif v:shell_error
                                return [0, 'Checking ' . prog_path . ' caused an unknown error. '
                                      \ . '(' . v:shell_error . ', output: ' . prog_ver . ')'
                                      \ . ' Report this at https://github.com/neovim/neovim']
                              endif
                            
                              return [1, '']
                            endfunction

SCRIPT  /usr/local/Cellar/neovim/0.2.2_1/share/nvim/runtime/autoload/provider.vim
Sourced 1 time
Total time:   0.000155
 Self time:   0.000155

count  total (s)   self (s)
                            " Common functionality for providers
                            
    1              0.000005 let s:stderr = {}
                            
    1              0.000004 function! provider#stderr_collector(chan_id, data, event)
                               let stderr = get(s:stderr, a:chan_id, [''])
                               let stderr[-1] .= a:data[0]
                               call extend(stderr, a:data[1:])
                               let s:stderr[a:chan_id] = stderr
                            endfunction
                            
    1              0.000003 function! provider#clear_stderr(chan_id)
                              if has_key(s:stderr, a:chan_id)
                                call remove(s:stderr, a:chan_id)
                              endif
                            endfunction
                            
    1              0.000002 function! provider#get_stderr(chan_id)
                               return get(s:stderr, a:chan_id, [])
                            endfunction

SCRIPT  /Users/asheqimran/.vim/plugged/editorconfig-vim/autoload/editorconfig.vim
Sourced 1 time
Total time:   0.000171
 Self time:   0.000171

count  total (s)   self (s)
                            " Copyright (c) 2011-2012 EditorConfig Team
                            " All rights reserved.
                            " 
                            " Redistribution and use in source and binary forms, with or without
                            " modification, are permitted provided that the following conditions are met:
                            " 
                            " 1. Redistributions of source code must retain the above copyright notice,
                            "    this list of conditions and the following disclaimer.
                            " 2. Redistributions in binary form must reproduce the above copyright notice,
                            "    this list of conditions and the following disclaimer in the documentation
                            "    and/or other materials provided with the distribution.
                            " 
                            " THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            " AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            " IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
                            " ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
                            " LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
                            " CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
                            " SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
                            " INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
                            " CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
                            " ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
                            " POSSIBILITY OF SUCH DAMAGE.
                            "
                            
    1              0.000004 if v:version < 700
                                finish
                            endif
                            
    1              0.000008 let s:saved_cpo = &cpo
    1              0.000008 set cpo&vim
                            
                            " {{{1 variables
    1              0.000003 let s:hook_list = []
                            
    1              0.000004 function editorconfig#AddNewHook(func) " {{{1
                                " Add a new hook
                            
                                call add(s:hook_list, a:func)
                            endfunction
                            
    1              0.000003 function editorconfig#ApplyHooks(config) " {{{1
                                " apply hooks
                            
                                for Hook in s:hook_list
                                    let l:hook_ret = Hook(a:config)
                            
                                    if type(l:hook_ret) != type(0) && l:hook_ret != 0
                                        " TODO print some debug info here
                                    endif
                                endfor
                            endfunction
                            
                            " }}}
                            
    1              0.000007 let &cpo = s:saved_cpo
    1              0.000002 unlet! s:saved_cpo
                            
                            " vim: fdm=marker fdc=3

FUNCTION  remote#host#Require()
Called 1 time
Total time:   0.599890
 Self time:   0.000041

count  total (s)   self (s)
    1              0.000003   if !has_key(s:hosts, a:name)
                                throw 'No host named "'.a:name.'" is registered'
                              endif
    1              0.000002   let host = s:hosts[a:name]
    1              0.000001   if !host.channel && !host.initialized
    1              0.000005     let host_info = { 'name': a:name, 'orig_name': get(host, 'orig_name', a:name) }
    1   0.599869   0.000020     let host.channel = call(host.factory, [host_info])
    1              0.000003     let host.initialized = 1
    1              0.000000   endif
    1              0.000002   return host.channel

FUNCTION  <SNR>88_set_altbuf()
Called 3 times
Total time:   0.000038
 Self time:   0.000020

count  total (s)   self (s)
    3   0.000036   0.000019   if !s:is_valid_altbuf(a:bnr) | return | endif
                            
                              if has('patch-7.4.605') | let @# = a:bnr | return | endif
                            
                              let curbuf = bufnr('%')
                              if s:try_visit(a:bnr, 1)
                                let noau = bufloaded(curbuf) ? 'noau' : ''
                                " Return to the current buffer.
                                execute 'silent keepjumps' noau s:noswapfile 'buffer' curbuf
                              endif

FUNCTION  <SNR>53_UseConfigFiles_Python_Builtin()
Called 1 time
Total time:   0.002909
 Self time:   0.002001

count  total (s)   self (s)
                            " Use built-in python to run the python EditorConfig core
                            
    1              0.000003     let l:config = {}
                            
    1              0.000002     let l:ret = 0
    1              0.001965     execute s:py_cmd 'ec_UseConfigFiles()'
    1              0.000004     if l:ret != 0
                                    return l:ret
                                endif
                            
    1   0.000926   0.000018     call s:ApplyConfig(l:config)
                            
    1              0.000001     return l:ret

FUNCTION  AutoSave()
Called 1 time
Total time:   0.000022
 Self time:   0.000012

count  total (s)   self (s)
    1              0.000001   if g:auto_save == 0
                                return
                              end
                            
    1   0.000017   0.000008   let was_modified = s:IsModified()
    1              0.000001   if !was_modified
    1              0.000000     return
                              end
                            
                              if exists("g:auto_save_presave_hook")
                                let g:auto_save_abort = 0
                                execute "" . g:auto_save_presave_hook
                                if g:auto_save_abort >= 1
                                  return
                                endif
                              endif
                            
                              " Preserve marks that are used to remember start and
                              " end position of the last changed or yanked text (`:h '[`).
                              let first_char_pos = getpos("'[")
                              let last_char_pos = getpos("']")
                            
                              call DoSave()
                            
                              call setpos("'[", first_char_pos)
                              call setpos("']", last_char_pos)
                            
                              if was_modified && !&modified
                                if exists("g:auto_save_postsave_hook")
                                  execute "" . g:auto_save_postsave_hook
                                endif
                            
                                if g:auto_save_silent == 0
                                  echo "(AutoSave) saved at " . strftime("%H:%M:%S")
                                endif
                              endif

FUNCTION  <SNR>88_globlist()
Called 4 times
Total time:   0.001606
 Self time:   0.001579

count  total (s)   self (s)
    4   0.001603   0.001576   return glob(a:pat, !s:suf(), 1)

FUNCTION  <SNR>60_can_diffoff()
Called 3 times
Total time:   0.000028
 Self time:   0.000028

count  total (s)   self (s)
    3              0.000026   return getwinvar(bufwinnr(a:buf), '&diff') && !empty(getbufvar(a:buf, 'git_dir')) && !empty(getwinvar(bufwinnr(a:buf), 'fugitive_diff_restore'))

FUNCTION  fugitive#detect()
Called 3 times
Total time:   0.004870
 Self time:   0.000809

count  total (s)   self (s)
    3              0.000014   if exists('b:git_dir') && (b:git_dir ==# '' || b:git_dir =~# '/$')
                                unlet b:git_dir
                              endif
    3              0.000005   if !exists('b:git_dir')
    2   0.000787   0.000017     let dir = fugitive#extract_git_dir(a:path)
    2              0.000003     if dir !=# ''
    2              0.000003       let b:git_dir = dir
    2   0.001357   0.000039       if empty(fugitive#buffer().path())
    1              0.000101         silent! exe haslocaldir() ? 'lcd .' : 'cd .'
    1              0.000001       endif
    2              0.000001     endif
    2              0.000001   endif
    3              0.000007   if exists('b:git_dir')
    3              0.000010     if exists('#User#FugitiveBoot')
                                  try
                                    let [save_mls, &modelines] = [&mls, 0]
                                    doautocmd User FugitiveBoot
                                  finally
                                    let &mls = save_mls
                                  endtry
                                endif
    3              0.000006     if !exists('g:fugitive_no_maps')
    3              0.000102       cnoremap <buffer> <expr> <C-R><C-G> fnameescape(<SID>recall())
    3              0.000041       nnoremap <buffer> <silent> y<C-G> :call setreg(v:register, <SID>recall())<CR>
    3              0.000002     endif
    3   0.000108   0.000013     let buffer = fugitive#buffer()
    3              0.000066     if expand('%:p') =~# '://'
                                  call buffer.setvar('&path', s:sub(buffer.getvar('&path'), '^\.%(,|$)', ''))
                                endif
    3   0.000035   0.000024     if stridx(buffer.getvar('&tags'), escape(b:git_dir, ', ')) == -1
    3              0.000038       if filereadable(b:git_dir.'/tags')
                                    call buffer.setvar('&tags', escape(b:git_dir.'/tags', ', ').','.buffer.getvar('&tags'))
                                  endif
    3              0.000037       if &filetype !=# '' && filereadable(b:git_dir.'/'.&filetype.'.tags')
                                    call buffer.setvar('&tags', escape(b:git_dir.'/'.&filetype.'.tags', ', ').','.buffer.getvar('&tags'))
                                  endif
    3              0.000001     endif
    3              0.000002     try
    3              0.000025       let [save_mls, &modelines] = [&mls, 0]
    3   0.000710   0.000016       call s:define_commands()
    3   0.001290   0.000118       doautocmd User Fugitive
    3              0.000002     finally
    3              0.000015       let &mls = save_mls
    3              0.000002     endtry
    3              0.000001   endif

FUNCTION  <SNR>53_ResetShellSlash()
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
                                " reset shellslash to the user-set value, if any
    1              0.000002     if exists('s:old_shellslash')
                                    let &l:shellslash = s:old_shellslash
                                    unlet! s:old_shellslash
                                endif

FUNCTION  <SNR>88_sl()
Called 18 times
Total time:   0.000069
 Self time:   0.000069

count  total (s)   self (s)
   18              0.000061   return tr(a:path, '\', '/')

FUNCTION  <SNR>53_UseConfigFiles()
Called 1 time
Total time:   1.105677
 Self time:   0.000161

count  total (s)   self (s)
                            
    1              0.000022     let l:buffer_name = expand('%:p')
                                " ignore buffers without a name
    1              0.000002     if empty(l:buffer_name)
                                    return
                                endif
                            
                                " Check if any .editorconfig does exist
    1   0.000071   0.000022     let l:conf_files = s:GetFilenames(expand('%:p:h'), '.editorconfig')
    1              0.000001     let l:conf_found = 0
    1              0.000002     for conf_file in conf_files
    1              0.000020         if filereadable(conf_file)
    1              0.000002             let l:conf_found = 1
    1              0.000001             break
                                    endif
                                endfor
    1              0.000001     if !l:conf_found
                                    return
                                endif
                            
    1              0.000001     if g:EditorConfig_verbose
                                    echo 'Applying EditorConfig on file "' . l:buffer_name . '"'
                                endif
                            
    1              0.000001     if !s:initialized
    1   1.102573   0.000015         if s:Initialize()
                                        return
                                    endif
    1              0.000001     endif
                            
                                " Ignore specific patterns
    1              0.000004     for pattern in g:EditorConfig_exclude_patterns
                                    if l:buffer_name =~ pattern
                                        return
                                    endif
                                endfor
                            
    1              0.000003     if s:editorconfig_core_mode == 'external_command'
                                    call s:UseConfigFiles_ExternalCommand()
                                elseif s:editorconfig_core_mode == 'python_builtin'
    1   0.002933   0.000024         call s:UseConfigFiles_Python_Builtin()
    1              0.000002     elseif s:editorconfig_core_mode == 'python_external'
                                    call s:UseConfigFiles_Python_External()
                                else
                                    echohl Error | echo "Unknown EditorConfig Core: " . s:editorconfig_core_mode | echohl None
                                endif

FUNCTION  <SNR>88_buf_init()
Called 2 times
Total time:   0.000280
 Self time:   0.000280

count  total (s)   self (s)
    2              0.000004   augroup dirvish_buflocal
    2              0.000227     autocmd! * <buffer>
    2              0.000008     autocmd BufEnter,WinEnter <buffer> call <SID>on_bufenter()
    2              0.000009     autocmd TextChanged,TextChangedI <buffer> if <SID>buf_modified()&& has('conceal')|exe 'setlocal conceallevel=0'|endif
                            
                                " BufUnload is fired for :bwipeout/:bdelete/:bunload, _even_ if
                                " 'nobuflisted'. BufDelete is _not_ fired if 'nobuflisted'.
                                " NOTE: For 'nohidden' we cannot reliably handle :bdelete like this.
    2              0.000002     if &hidden
    2              0.000005       autocmd BufUnload <buffer> call s:on_bufunload()
    2              0.000001     endif
    2              0.000001   augroup END
                            
    2              0.000015   setlocal buftype=nofile noswapfile

FUNCTION  <SNR>60_repo_tree()
Called 6 times
Total time:   0.000214
 Self time:   0.000163

count  total (s)   self (s)
    6   0.000073   0.000046   if self.dir() =~# '/\.git$'
    6   0.000049   0.000025     let dir = self.dir()[0:-6]
    6              0.000015     if dir !~# '/'
                                  let dir .= '/'
                                endif
    6              0.000003   else
                                let dir = s:configured_tree(self.git_dir)
                              endif
    6              0.000007   if dir ==# ''
                                call s:throw('no work tree')
                              else
    6              0.000022     return join([dir]+a:000,'/')
                              endif

FUNCTION  <SNR>53_Initialize()
Called 1 time
Total time:   1.102557
 Self time:   0.000132

count  total (s)   self (s)
                                " Do some initalization for the case that the user has specified core mode {{{2
    1              0.000002     if !empty(s:editorconfig_core_mode)
                            
                                    if s:editorconfig_core_mode == 'external_command'
                                        if s:InitializeExternalCommand()
                                            echo 'EditorConfig: Failed to initialize external_command mode'
                                            return 1
                                        endif
                                    else
                                        let s:editorconfig_core_py_dir = s:FindPythonFiles()
                            
                                        if empty(s:editorconfig_core_py_dir)
                                            echo 'EditorConfig: '. 'EditorConfig Python Core files could not be found.'
                                            return 1
                                        endif
                            
                                        if s:editorconfig_core_mode == 'python_builtin' && s:InitializePythonBuiltin(s:editorconfig_core_py_dir)
                                            echo 'EditorConfig: Failed to initialize vim built-in python.'
                                            return 1
                                        elseif s:editorconfig_core_mode == 'python_external' && s:InitializePythonExternal()
                                            echo 'EditorConfig: Failed to find external Python interpreter.'
                                            return 1
                                        endif
                                    endif
                                endif
                            
                                " Determine the editorconfig_core_mode we should use {{{2
    1              0.000001     while 1
                                    " If user has specified a mode, just break
    1              0.000003         if exists('s:editorconfig_core_mode') && !empty(s:editorconfig_core_mode)
                                        break
                                    endif
                            
                                    " Find Python core files. If not found, we try external_command mode
    1   0.001608   0.000009         let s:editorconfig_core_py_dir = s:FindPythonFiles()
    1              0.000002         if empty(s:editorconfig_core_py_dir) " python files are not found
                                        if !s:InitializeExternalCommand()
                                            let s:editorconfig_core_mode = 'external_command'
                                        endif
                                        break
                                    endif
                            
                                    " Builtin python mode first
    1   1.100846   0.000019         if !s:InitializePythonBuiltin(s:editorconfig_core_py_dir)
    1              0.000007             let s:editorconfig_core_mode = 'python_builtin'
    1              0.000002             break
                                    endif
                            
                                    " Then external_command mode
                                    if !s:InitializeExternalCommand()
                                        let s:editorconfig_core_mode = 'external_command'
                                        break
                                    endif
                            
                                    " Finally external python mode
                                    if !s:InitializePythonExternal()
                                        let s:editorconfig_core_mode = 'python_external'
                                        break
                                    endif
                            
                                    break
                                endwhile
                            
                                " No EditorConfig Core is available
    1              0.000004     if empty(s:editorconfig_core_mode)
                                    echo "EditorConfig: ". "No EditorConfig Core is available. The plugin won't work."
                                    return 1
                                endif
                                " }}}
                            
    1              0.000002     let s:initialized = 1
    1              0.000004     return 0

FUNCTION  <SNR>60_buffer()
Called 11 times
Total time:   0.000312
 Self time:   0.000272

count  total (s)   self (s)
   11              0.000053   let buffer = {'#': bufnr(a:0 ? a:1 : '%')}
   11              0.000141   call extend(extend(buffer,s:buffer_prototype,'keep'),s:abstract_prototype,'keep')
   11   0.000097   0.000058   if buffer.getvar('git_dir') !=# ''
   11              0.000009     return buffer
                              endif
                              call s:throw('not a git repository: '.expand('%:p'))

FUNCTION  <SNR>54_isdir()
Called 2 times
Total time:   0.000052
 Self time:   0.000052

count  total (s)   self (s)
    2              0.000050   return !empty(a:dir) && (isdirectory(a:dir) || (!empty($SYSTEMDRIVE) && isdirectory('/'.tolower($SYSTEMDRIVE[0]).a:dir)))

FUNCTION  <SNR>12_LoadIndent()
Called 3 times
Total time:   0.001547
 Self time:   0.001323

count  total (s)   self (s)
    3              0.000008     if exists("b:undo_indent")
                                  exe b:undo_indent
                                  unlet! b:undo_indent b:did_indent
                                endif
    3              0.000009     let s = expand("<amatch>")
    3              0.000004     if s != ""
    3              0.000005       if exists("b:did_indent")
                            	unlet b:did_indent
                                  endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
    6              0.000019       for name in split(s, '\.')
    3   0.001469   0.001245 	exe 'runtime! indent/' . name . '.vim'
    3              0.000003       endfor
    3              0.000002     endif

FUNCTION  provider#pythonx#Detect()
Called 1 time
Total time:   0.487068
 Self time:   0.000058

count  total (s)   self (s)
    1              0.000003   if a:major_ver == 2
    1              0.000003     if exists('g:python_host_prog')
                                  return [g:python_host_prog, '']
                                else
    1              0.000004       let progs = ['python2', 'python2.7', 'python2.6', 'python']
    1              0.000001     endif
    1              0.000001   else
                                if exists('g:python3_host_prog')
                                  return [g:python3_host_prog, '']
                                else
                                  let progs = ['python3', 'python3.7', 'python3.6', 'python3.5', 'python3.4', 'python3.3', 'python']
                                endif
                              endif
                            
    1              0.000002   let errors = []
                            
    1              0.000002   for prog in progs
    1   0.487035   0.000025     let [result, err] = s:check_interpreter(prog, a:major_ver)
    1              0.000001     if result
    1              0.000004       return [prog, err]
                                endif
                                " Accumulate errors in case we don't find
                                " any suitable Python interpreter.
                                call add(errors, err)
                              endfor
                            
                              " No suitable Python interpreter found.
                              return ['', 'provider/pythonx: Could not load Python ' . a:major_ver . ":\n" .  join(errors, "\n")]

FUNCTION  <SNR>14_SynSet()
Called 3 times
Total time:   0.010472
 Self time:   0.002834

count  total (s)   self (s)
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
    3              0.000010   syn clear
    3              0.000007   if exists("b:current_syntax")
                                unlet b:current_syntax
                              endif
                            
    3              0.000008   let s = expand("<amatch>")
    3              0.000004   if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
                              elseif s == "OFF"
                                let s = ""
                              endif
                            
    3              0.000003   if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.
    6              0.000020     for name in split(s, '\.')
    3   0.010371   0.002733       exe "runtime! syntax/" . name . ".vim syntax/" . name . "/*.vim"
    3              0.000004     endfor
    3              0.000002   endif

FUNCTION  <SNR>88_parent_dir()
Called 2 times
Total time:   0.000204
 Self time:   0.000079

count  total (s)   self (s)
    2   0.000048   0.000041   let mod = isdirectory(s:sl(a:dir)) ? ':p:h:h' : ':p:h'
    2   0.000155   0.000037   return s:normalize_dir(fnamemodify(a:dir, mod))

FUNCTION  <SNR>60_buffer_getline()
Called 9 times
Total time:   0.000042
 Self time:   0.000042

count  total (s)   self (s)
    9              0.000039   return get(getbufline(self['#'], a:lnum), 0, '')

FUNCTION  <SNR>88_normalize_dir()
Called 4 times
Total time:   0.000243
 Self time:   0.000228

count  total (s)   self (s)
    4   0.000038   0.000022   let dir = s:sl(a:dir)
    4              0.000069   if !isdirectory(dir)
                                "cygwin/MSYS fallback for paths that lack a drive letter.
                                let dir = empty($SYSTEMDRIVE) ? dir : '/'.tolower($SYSTEMDRIVE[0]).(dir)
                                if !isdirectory(dir)
                                  call s:msg_error("invalid directory: '".a:dir."'")
                                  return ''
                                endif
                              endif
                              " Collapse slashes (except UNC-style \\foo\bar).
    4              0.000070   let dir = dir[0] . substitute(dir[1:], '/\+', '/', 'g')
                              " Always end with separator.
    4              0.000013   return (dir[-1:] ==# '/') ? dir : dir.'/'

FUNCTION  remote#host#IsRunning()
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000002   if !has_key(s:hosts, a:name)
                                throw 'No host named "'.a:name.'" is registered'
                              endif
    1              0.000002   return s:hosts[a:name].channel != 0

FUNCTION  <SNR>60_shellslash()
Called 22 times
Total time:   0.000331
 Self time:   0.000186

count  total (s)   self (s)
   22   0.000231   0.000086   if s:winshell()
                                return s:gsub(a:path,'\\','/')
                              else
   22              0.000022     return a:path
                              endif

FUNCTION  <SNR>88_list_dir()
Called 2 times
Total time:   0.002105
 Self time:   0.000499

count  total (s)   self (s)
                              " Escape for glob().
    2              0.000014   let dir_esc = substitute(a:dir,'\V[','[[]','g')
    2   0.001006   0.000021   let paths = s:globlist(dir_esc.'*')
                              "Append dot-prefixed files. glob() cannot do both in 1 pass.
    2   0.000655   0.000034   let paths = paths + s:globlist(dir_esc.'.[^.]*')
                            
    2              0.000013   if get(g:, 'dirvish_relative_paths', 0) && a:dir != s:parent_dir(getcwd()) "avoid blank CWD
                                return map(paths, "fnamemodify(v:val, ':p:.')")
                              else
    2              0.000406     return map(paths, "fnamemodify(v:val, ':p')")
                              endif

FUNCTION  <SNR>88_suf()
Called 4 times
Total time:   0.000027
 Self time:   0.000027

count  total (s)   self (s)
    4              0.000013   let m = get(g:, 'dirvish_mode', 1)
    4              0.000012   return type(m) == type(0) && m <= 1 ? 1 : 0

FUNCTION  editorconfig#ApplyHooks()
Called 1 time
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
                                " apply hooks
                            
    1              0.000003     for Hook in s:hook_list
                                    let l:hook_ret = Hook(a:config)
                            
                                    if type(l:hook_ret) != type(0) && l:hook_ret != 0
                                        " TODO print some debug info here
                                    endif
                                endfor

FUNCTION  <SNR>60_sub()
Called 10 times
Total time:   0.000082
 Self time:   0.000082

count  total (s)   self (s)
   10              0.000078   return substitute(a:str,'\v\C'.a:pat,a:rep,'')

FUNCTION  undotree#UndotreeUpdate()
Called 6 times
Total time:   0.000041
 Self time:   0.000041

count  total (s)   self (s)
    6              0.000026     if !exists('t:undotree')
    6              0.000007         return
                                endif
                                if !exists('w:undotree_id')
                                    let w:undotree_id = 'id_'.s:getUniqueID()
                                    call s:log("Unique window id assigned: ".w:undotree_id)
                                endif
                                " assume window layout won't change during updating.
                                let thiswinnr = winnr()
                                call t:undotree.Update()
                                " focus moved
                                if winnr() != thiswinnr
                                    call s:exec("norm! ".thiswinnr."\<c-w>\<c-w>")
                                endif

FUNCTION  <SNR>53_IsRuleActive()
Called 8 times
Total time:   0.000038
 Self time:   0.000038

count  total (s)   self (s)
    8              0.000034     return index(g:EditorConfig_disable_rules, a:name) < 0 && has_key(a:config, a:name)

FUNCTION  fugitive#extract_git_dir()
Called 2 times
Total time:   0.000771
 Self time:   0.000419

count  total (s)   self (s)
    2   0.000064   0.000021   if s:shellslash(a:path) =~# '^fugitive://.*//'
                                return matchstr(s:shellslash(a:path), '\C^fugitive://\zs.\{-\}\ze//')
                              endif
    2              0.000035   if isdirectory(a:path)
    1              0.000021     let path = fnamemodify(a:path, ':p:s?[\/]$??')
    1              0.000001   else
    1              0.000027     let path = fnamemodify(a:path, ':p:h:s?[\/]$??')
    1              0.000001   endif
    2   0.000063   0.000036   let root = s:shellslash(resolve(path))
    2              0.000003   let previous = ""
    2              0.000004   while root !=# previous
    2              0.000012     if root =~# '\v^//%([^/]+/?)?$'
                                  " This is for accessing network shares from Cygwin Vim. There won't be
                                  " any git directory called //.git or //serverName/.git so let's avoid
                                  " checking for them since such checks are extremely slow.
                                  break
                                endif
    2              0.000015     if index(split($GIT_CEILING_DIRECTORIES, ':'), root) >= 0
                                  break
                                endif
    2              0.000007     if root ==# $GIT_WORK_TREE && fugitive#is_git_dir($GIT_DIR)
                                  return simplify(fnamemodify(expand($GIT_DIR), ':p:s?[\/]$??'))
                                endif
    2   0.000068   0.000011     if fugitive#is_git_dir($GIT_DIR)
                                  " Ensure that we've cached the worktree
                                  call s:configured_tree(simplify(fnamemodify(expand($GIT_DIR), ':p:s?[\/]$??')))
                                  if has_key(s:dir_for_worktree, root)
                                    return s:dir_for_worktree[root]
                                  endif
                                endif
    2   0.000030   0.000012     let dir = s:sub(root, '[\/]$', '') . '/.git'
    2              0.000137     let type = getftype(dir)
    2   0.000221   0.000014     if type ==# 'dir' && fugitive#is_git_dir(dir)
    2              0.000003       return dir
                                elseif type ==# 'link' && fugitive#is_git_dir(dir)
                                  return resolve(dir)
                                elseif type !=# '' && filereadable(dir)
                                  let line = get(readfile(dir, '', 1), 0, '')
                                  if line =~# '^gitdir: \.' && fugitive#is_git_dir(root.'/'.line[8:-1])
                                    return simplify(root.'/'.line[8:-1])
                                  elseif line =~# '^gitdir: ' && fugitive#is_git_dir(line[8:-1])
                                    return line[8:-1]
                                  endif
                                elseif fugitive#is_git_dir(root)
                                  return root
                                endif
                                let previous = root
                                let root = fnamemodify(root, ':h')
                              endwhile
                              return ''

FUNCTION  dirvish#open()
Called 3 times
Total time:   1.152257
 Self time:   0.000185

count  total (s)   self (s)
    3              0.000009   if &autochdir
                                call s:msg_error("'autochdir' is not supported")
                                return
                              endif
    3              0.000017   if !&hidden && &modified && (!exists("*win_findbuf") || len(win_findbuf(winbufnr(0))) == 1)
                                call s:msg_error("E37: No write since last change")
                                return
                              endif
                            
    3              0.000004   if a:0 > 1
    1   1.126970   0.000032     call s:open_selected(a:1, a:2, a:firstline, a:lastline)
    1              0.000003     return
                              endif
                            
    2              0.000004   let d = {}
    2              0.000085   let from_path = fnamemodify(bufname('%'), ':p')
    2   0.000062   0.000052   let to_path   = fnamemodify(s:sl(a:1), ':p')
                              "                                       ^resolves to CWD if a:1 is empty
                            
    2              0.000035   let d._dir = filereadable(to_path) ? fnamemodify(to_path, ':p:h') : to_path
    2   0.000143   0.000017   let d._dir = s:normalize_dir(d._dir)
    2              0.000004   if '' ==# d._dir " s:normalize_dir() already showed error.
                                return
                              endif
                            
    2              0.000009   let reloading = exists('b:dirvish') && d._dir ==# b:dirvish._dir
                            
    2              0.000002   if reloading
                                let d.lastpath = ''         " Do not place cursor when reloading.
                              elseif d._dir ==# s:parent_dir(from_path)
                                let d.lastpath = from_path  " Save lastpath when navigating _up_.
                              endif
                            
    2   0.000377   0.000017   call s:save_state(d)
    2   0.009454   0.001251   call s:open_dir(d, reloading)

FUNCTION  remote#host#RegisterClone()
Called 1 time
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
    1              0.000006   if !has_key(s:hosts, a:orig_name)
                                throw 'No host named "'.a:orig_name.'" is registered'
                              endif
    1              0.000006   let Factory = s:hosts[a:orig_name].factory
    1              0.000006   let s:hosts[a:name] = { 'factory': Factory, 'channel': 0, 'initialized': 0, 'orig_name': a:orig_name }

FUNCTION  <SNR>53_FindPythonFiles()
Called 1 time
Total time:   0.001599
 Self time:   0.001583

count  total (s)   self (s)
                            " Find EditorConfig Core python files
                            
    1   0.000017   0.000008     call s:DisableShellSlash()
                            
    1              0.001532     let l:python_core_files_dir = fnamemodify( findfile(g:EditorConfig_python_files_dir . '/main.py', ','.&runtimepath), ':p:h')
                            
    1              0.000003     if empty(l:python_core_files_dir)
                                    let l:python_core_files_dir = ''
                                else
                            
                                    " expand python core file path to full path, and remove the appending '/'
    1              0.000022         let l:python_core_files_dir = substitute( fnamemodify(l:python_core_files_dir, ':p'), '/$', '', '')
    1              0.000001     endif
                            
    1   0.000016   0.000010     call s:ResetShellSlash()
                            
    1              0.000001     return l:python_core_files_dir

FUNCTION  <SNR>60_buffer_commit()
Called 3 times
Total time:   0.000157
 Self time:   0.000033

count  total (s)   self (s)
    3   0.000156   0.000031   return matchstr(self.spec(),'^fugitive://.\{-\}//\zs\w*')

FUNCTION  <SNR>60_repo_bare()
Called 2 times
Total time:   0.000031
 Self time:   0.000022

count  total (s)   self (s)
    2   0.000028   0.000019   if self.dir() =~# '/\.git$'
    2              0.000002     return 0
                              else
                                return s:configured_tree(self.git_dir) ==# ''
                              endif

FUNCTION  AutoRestoreWinView()
Called 2 times
Total time:   0.000061
 Self time:   0.000061

count  total (s)   self (s)
    2              0.000009   let buf = bufnr("%")
    2              0.000012   if exists("w:SavedBufView") && has_key(w:SavedBufView, buf)
                                let v = winsaveview()
                                let atStartOfFile = v.lnum == 1 && v.col == 0
                                if atStartOfFile && !&diff
                                  " START TEMPORARY FIX
                                  if (line('$') > winheight(0) && w:SavedBufView[buf].topline == 1 && w:SavedBufView[buf].lnum > winheight(0)/2)
                                    let w:SavedBufView[buf].topline = 2
                                  endif
                                  " END TEMPORARY FIX
                                  call winrestview(w:SavedBufView[buf])
                                endif
                                unlet w:SavedBufView[buf]
                              endif

FUNCTION  <SNR>53_InitializePythonBuiltin()
Called 1 time
Total time:   1.100826
 Self time:   0.612652

count  total (s)   self (s)
                            " Initialize builtin python. The parameter is the Python Core directory
                            
    1              0.000003     if exists('s:builtin_python_initialized') && s:builtin_python_initialized
                                    return 0
                                endif
                            
    1              0.000002     let s:builtin_python_initialized = 1
                            
    1   0.488660   0.000485     if has('python')
    1              0.000006         let s:pyfile_cmd = 'pyfile'
    1              0.000002         let s:py_cmd = 'py'
    1              0.000002     elseif has('python3')
                                    let s:pyfile_cmd = 'py3file'
                                    let s:py_cmd = 'py3'
                                else
                                    return 1
                                endif
                            
    1              0.000001     let l:ret = 0
                                " The following line modifies l:ret. This is a bit confusing but
                                " unfortunately to be compatible with Vim 7.3, we cannot use pyeval. This
                                " should be changed in the future.
    1              0.612130     execute s:pyfile_cmd fnameescape(s:pyscript_path)
                            
    1              0.000005     return l:ret

FUNCTION  <SNR>60_buffer_spec()
Called 18 times
Total time:   0.000705
 Self time:   0.000445

count  total (s)   self (s)
   18              0.000051     let bufname = bufname(self['#'])
   18   0.000644   0.000384     return s:shellslash(bufname == '' ? '' : fnamemodify(bufname,':p'))

FUNCTION  <SNR>88_tab_win_do()
Called 2 times
Total time:   0.000073
 Self time:   0.000073

count  total (s)   self (s)
    2              0.000015   exe s:noau 'tabnext' a:tnr
    4              0.000008   for wnr in range(1, tabpagewinnr(a:tnr, '$'))
    2              0.000005     if a:bname ==# bufname(winbufnr(wnr))
    2              0.000017       exe s:noau wnr.'wincmd w'
    2              0.000013       exe a:cmd
    2              0.000001     endif
    2              0.000001   endfor

FUNCTION  <SNR>88_save_state()
Called 2 times
Total time:   0.000360
 Self time:   0.000260

count  total (s)   self (s)
                              " Remember previous ('original') buffer.
    2   0.000064   0.000026   let a:d.prevbuf = s:buf_isvalid(bufnr('%')) || !exists('w:dirvish') ? 0+bufnr('%') : w:dirvish.prevbuf
    2   0.000042   0.000009   if !s:buf_isvalid(a:d.prevbuf)
                                "If reached via :edit/:buffer/etc. we cannot get the (former) altbuf.
    1              0.000007     let a:d.prevbuf = exists('b:dirvish') && s:buf_isvalid(b:dirvish.prevbuf) ? b:dirvish.prevbuf : bufnr('#')
    1              0.000001   endif
                            
                              " Remember alternate buffer.
    2   0.000160   0.000132   let a:d.altbuf = s:buf_isvalid(bufnr('#')) || !exists('w:dirvish') ? 0+bufnr('#') : w:dirvish.altbuf
    2              0.000010   if exists('b:dirvish') && (a:d.altbuf == a:d.prevbuf || !s:buf_isvalid(a:d.altbuf))
                                let a:d.altbuf = b:dirvish.altbuf
                              endif
                            
                              " Save window-local settings.
    2              0.000021   let w:dirvish = extend(get(w:, 'dirvish', {}), a:d, 'force')
    2              0.000016   let [w:dirvish._w_wrap, w:dirvish._w_cul] = [&l:wrap, &l:cul]
    2              0.000008   if has('conceal') && !exists('b:dirvish')
    2              0.000009     let [w:dirvish._w_cocu, w:dirvish._w_cole] = [&l:concealcursor, &l:conceallevel]
    2              0.000001   endif

FUNCTION  remote#host#PluginsForHost()
Called 2 times
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    2              0.000005   if !has_key(s:plugins_for_host, a:host)
    1              0.000002     let s:plugins_for_host[a:host] = []
    1              0.000001   end
    2              0.000003   return s:plugins_for_host[a:host]

FUNCTION  <SNR>53_GetFilenames()
Called 1 time
Total time:   0.000049
 Self time:   0.000049

count  total (s)   self (s)
                            " Yield full filepath for filename in each directory in and above path
                            
    1              0.000002     let l:path_list = []
    1              0.000001     let l:path = a:path
    4              0.000002     while 1
    4              0.000013         let l:path_list += [l:path . '/' . a:filename]
    4              0.000010         let l:newpath = fnamemodify(l:path, ':h')
    4              0.000005         if l:path == l:newpath
    1              0.000001             break
                                    endif
    3              0.000003         let l:path = l:newpath
    3              0.000002     endwhile
    1              0.000001     return l:path_list

FUNCTION  <SNR>60_winshell()
Called 22 times
Total time:   0.000145
 Self time:   0.000145

count  total (s)   self (s)
   22              0.000132   return &shell =~? 'cmd' || exists('+shellslash') && !&shellslash

FUNCTION  <SNR>88_is_valid_altbuf()
Called 3 times
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
    3              0.000016   return a:bnr != bufnr('%') && bufexists(a:bnr) && empty(getbufvar(a:bnr, 'dirvish'))

FUNCTION  <SNR>51_IsModified()
Called 1 time
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    1              0.000002   if g:auto_save_write_all_buffers >= 1
                                let buffers = filter(range(1, bufnr('$')), 'bufexists(v:val)')
                                call filter(buffers, 'getbufvar(v:val, "&modified")')
                                return len(buffers) > 0
                              else
    1              0.000001     return &modified
                              endif

FUNCTION  fugitive#is_git_dir()
Called 4 times
Total time:   0.000263
 Self time:   0.000231

count  total (s)   self (s)
    4   0.000058   0.000026   let path = s:sub(a:path, '[\/]$', '') . '/'
    4              0.000201   return getfsize(path.'HEAD') > 10 && ( isdirectory(path.'objects') && isdirectory(path.'refs') || getftype(path.'commondir') ==# 'file')

FUNCTION  <SNR>88_buf_isvalid()
Called 6 times
Total time:   0.000100
 Self time:   0.000084

count  total (s)   self (s)
    6   0.000097   0.000081   return bufexists(a:bnr) && !isdirectory(s:sl(bufname(a:bnr)))

FUNCTION  provider#clear_stderr()
Called 1 time
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    1              0.000005   if has_key(s:stderr, a:chan_id)
                                call remove(s:stderr, a:chan_id)
                              endif

FUNCTION  provider#python#Call()
Called 2 times
Total time:   0.614059
 Self time:   0.014168

count  total (s)   self (s)
    2              0.000004   if s:err != ''
                                return
                              endif
    2              0.000005   if !exists('s:host')
    1              0.000004     let s:rpcrequest = function('rpcrequest')
                            
                                " Ensure that we can load the Python host before bootstrapping
    1              0.000001     try
    1   0.599906   0.000016       let s:host = remote#host#Require('legacy-python-provider')
    1              0.000001     catch
                                  let s:err = v:exception
                                  echohl WarningMsg
                                  echomsg v:exception
                                  echohl None
                                  return
                                endtry
    1              0.000000   endif
    2              0.014108   return call(s:rpcrequest, insert(insert(a:args, 'python_'.a:method), s:host))

FUNCTION  <SNR>88_open_dir()
Called 2 times
Total time:   0.024237
 Self time:   0.000328

count  total (s)   self (s)
    2              0.000003   let d = a:d
    2              0.000037   let dirname_without_sep = substitute(d._dir, '[\\/]\+$', '', 'g')
                            
                              " Vim tends to 'simplify' buffer names. Examples (gvim 7.4.618):
                              "     ~\foo\, ~\foo, foo\, foo
                              " Try to find an existing buffer before creating a new one.
    2              0.000003   let bnr = -1
    5              0.000011   for pat in ['', ':~:.', ':~']
    4              0.000281     let bnr = bufnr('^'.fnamemodify(d._dir, pat).'$')
    4              0.000007     if -1 != bnr
    1              0.000001       break
                                endif
    3              0.000002   endfor
                            
    2              0.000002   if -1 == bnr
    1   0.001326   0.001284     execute 'silent' s:noswapfile 'edit' fnameescape(d._dir)
    1              0.000001   else
    1              0.000006     execute 'silent' s:noswapfile 'buffer' bnr
    1              0.000001   endif
                            
                              " Use :file to force a normalized path.
                              " - Avoids ".././..", ".", "./", etc. (breaks %:p, not updated on :cd).
                              " - Avoids [Scratch] in some cases (":e ~/" on Windows).
    2   0.000018   0.000012   if s:sl(bufname('%')) !=# d._dir
                                execute 'silent '.s:noswapfile.' file ' . fnameescape(d._dir)
                              endif
                            
    2              0.000034   if !isdirectory(bufname('%'))  " sanity check
                                throw 'invalid directory: '.bufname('%')
                              endif
                            
    2              0.000005   if &buflisted && bufnr('$') > 1
                                setlocal nobuflisted
                              endif
                            
    2   0.000039   0.000013   call s:set_altbuf(d.prevbuf) "in case of :bd, :read#, etc.
                            
    2              0.000011   let b:dirvish = exists('b:dirvish') ? extend(b:dirvish, d, 'force') : d
                            
    2   0.000291   0.000011   call s:buf_init()
    2   0.000052   0.000009   call s:win_init()
    2   0.000045   0.000013   if a:reload || s:should_reload()
    2   0.002608   0.000015     call s:buf_render(b:dirvish._dir, get(b:dirvish, 'lastpath', ''))
                                " Set up Dirvish before any other `FileType dirvish` handler.
    2   0.000937   0.000291     exe 'source '.fnameescape(s:srcdir.'/ftplugin/dirvish.vim')
    2   0.010187   0.000009     setlocal filetype=dirvish
    2              0.000004     let b:dirvish._c = b:changedtick
    2              0.000001   endif

FUNCTION  <SNR>88_bufwin_do()
Called 2 times
Total time:   0.000202
 Self time:   0.000129

count  total (s)   self (s)
    2              0.000011   let [curtab, curwin, curwinalt] = [tabpagenr(), winnr(), winnr('#')]
    4              0.000008   for tnr in range(1, tabpagenr('$'))
    2              0.000009     let [origwin, origwinalt] = [tabpagewinnr(tnr), tabpagewinnr(tnr, '#')]
    2              0.000005     for bnr in tabpagebuflist(tnr)
    2              0.000005       if a:bname ==# bufname(bnr) " tab has at least 1 matching window
    2   0.000086   0.000013         call s:tab_win_do(tnr, a:cmd, a:bname)
    2              0.000019         exe s:noau origwinalt.'wincmd w|' s:noau origwin.'wincmd w'
    2              0.000001         break
                                  endif
                                endfor
    2              0.000001   endfor
    2              0.000011   exe s:noau 'tabnext '.curtab
    2              0.000018   exe s:noau curwinalt.'wincmd w|' s:noau curwin.'wincmd w'

FUNCTION  <SNR>60_repo()
Called 12 times
Total time:   0.000265
 Self time:   0.000265

count  total (s)   self (s)
   12              0.000055   let dir = a:0 ? a:1 : (exists('b:git_dir') && b:git_dir !=# '' ? b:git_dir : fugitive#extract_git_dir(expand('%:p')))
   12              0.000015   if dir !=# ''
   12              0.000025     if has_key(s:repos, dir)
   12              0.000028       let repo = get(s:repos, dir)
   12              0.000007     else
                                  let repo = {'git_dir': dir}
                                  let s:repos[dir] = repo
                                endif
   12              0.000087     return extend(extend(repo, s:repo_prototype, 'keep'), s:abstract_prototype, 'keep')
                              endif
                              call s:throw('not a git repository: '.expand('%:p'))

FUNCTION  <SNR>73_Highlight_Matching_Pair()
Called 5 times
Total time:   0.000444
 Self time:   0.000444

count  total (s)   self (s)
                              " Remove any previous match.
    5              0.000016   if exists('w:paren_hl_on') && w:paren_hl_on
                                silent! call matchdelete(3)
                                let w:paren_hl_on = 0
                              endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
    5              0.000021   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
                              endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
    5              0.000016   let c_lnum = line('.')
    5              0.000011   let c_col = col('.')
    5              0.000006   let before = 0
                            
    5              0.000013   let text = getline(c_lnum)
    5              0.000098   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
    5              0.000010   if empty(matches)
                                let [c_before, c] = ['', '']
                              else
    5              0.000020     let [c_before, c] = matches[1:2]
    5              0.000003   endif
    5              0.000068   let plist = split(&matchpairs, '.\zs[:,]')
    5              0.000016   let i = index(plist, c)
    5              0.000005   if i < 0
                                " not found, in Insert mode try character before the cursor
    5              0.000023     if c_col > 1 && (mode() == 'i' || mode() == 'R')
                                  let before = strlen(c_before)
                                  let c = c_before
                                  let i = index(plist, c)
                                endif
    5              0.000004     if i < 0
                                  " not found, nothing to do
    5              0.000003       return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
                              if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
                              else
                                let s_flags = 'nbW'
                                let c2 = c
                                let c = plist[i - 1]
                              endif
                              if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
                              if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
                              endif
                            
                              " Build an expression that detects whether the current cursor position is in
                              " certain syntax types (string, comment, etc.), for use as searchpairpos()'s
                              " skip argument.
                              " We match "escape" for special items, such as lispEscapeSpecial.
                              let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
                              " If executing the expression determines that the cursor is currently in
                              " one of the syntax types, then we want searchpairpos() to find the pair
                              " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                              " outside of the syntax types and s_skip should keep its value so we skip any
                              " matching pair inside the syntax types.
                              execute 'if' s_skip '| let s_skip = 0 | endif'
                            
                              " Limit the search to lines visible in the window.
                              let stoplinebottom = line('w$')
                              let stoplinetop = line('w0')
                              if i % 2 == 0
                                let stopline = stoplinebottom
                              else
                                let stopline = stoplinetop
                              endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
                              if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
                                let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
                              endif
                              try
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
                              if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
                              endif
                            
                              " If a match is found setup match highlighting.
                              if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
                                if exists('*matchaddpos')
                                  call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                endif
                                let w:paren_hl_on = 1
                              endif

FUNCTION  <SNR>60_buffer_type()
Called 3 times
Total time:   0.000614
 Self time:   0.000305

count  total (s)   self (s)
    3   0.000019   0.000011   if self.getvar('fugitive_type') != ''
                                let type = self.getvar('fugitive_type')
                              elseif fnamemodify(self.spec(),':p') =~# '.\git/refs/\|\.git/\w*HEAD$'
                                let type = 'head'
                              elseif self.getline(1) =~ '^tree \x\{40\}$' && self.getline(2) == ''
                                let type = 'tree'
                              elseif self.getline(1) =~ '^\d\{6\} \w\{4\} \x\{40\}\>\t'
                                let type = 'tree'
                              elseif self.getline(1) =~ '^\d\{6\} \x\{40\}\> \d\t'
                                let type = 'index'
                              elseif isdirectory(self.spec())
    2              0.000003     let type = 'directory'
    2              0.000003   elseif self.spec() == ''
                                let type = 'null'
                              else
    1              0.000001     let type = 'file'
    1              0.000001   endif
    3              0.000002   if a:0
    3              0.000027     return !empty(filter(copy(a:000),'v:val ==# type'))
                              else
                                return type
                              endif

FUNCTION  <SNR>88_buf_modified()
Called 3 times
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    3              0.000009   return b:changedtick > get(b:dirvish, '_c', b:changedtick)

FUNCTION  <SNR>88_open_selected()
Called 1 time
Total time:   1.126939
 Self time:   0.004908

count  total (s)   self (s)
    1              0.000007   let curbuf = bufnr('%')
    1              0.000010   let [curtab, curwin, wincount] = [tabpagenr(), winnr(), winnr('$')]
    1              0.000003   let p = (a:splitcmd ==# 'p')  " Preview-mode
                            
    1              0.000004   let paths = getline(a:line1, a:line2)
    2              0.000004   for path in paths
    1   0.000015   0.000008     let path = s:sl(path)
    1              0.000095     if !isdirectory(path) && !filereadable(path)
                                  call s:msg_error("invalid (or access denied): ".path)
                                  continue
                                endif
                            
    1              0.000001     if p
                                  exe (winnr('$') > 1 ? 'wincmd p' : 'vsplit')
                                endif
                            
    1              0.000022     if isdirectory(path)
                                  exe (p || a:splitcmd ==# 'edit' ? '' : a:splitcmd.'|') 'Dirvish' fnameescape(path)
                                else
    1   1.126680   0.004668       exe (p ? 'edit' : a:splitcmd) fnameescape(path)
    1              0.000003     endif
                            
                                " Return to previous window after _each_ split, else we get lost.
    1              0.000003     if a:bg && (p || (a:splitcmd =~# 'sp' && winnr('$') > wincount))
                                  wincmd p
                                endif
    1              0.000001   endfor
                            
    1              0.000001   if a:bg "return to dirvish buffer
                                if a:splitcmd ==# 'tabedit'
                                  exe 'tabnext' curtab '|' curwin.'wincmd w'
                                elseif a:splitcmd ==# 'edit'
                                  execute 'silent keepalt keepjumps buffer' curbuf
                                endif
                              elseif !exists('b:dirvish') && exists('w:dirvish')
    1   0.000017   0.000005     call s:set_altbuf(w:dirvish.prevbuf)
    1              0.000001   endif

FUNCTION  <SNR>60_buffer_getvar()
Called 29 times
Total time:   0.000094
 Self time:   0.000094

count  total (s)   self (s)
   29              0.000083   return getbufvar(self['#'],a:var)

FUNCTION  <SNR>60_repo_dir()
Called 18 times
Total time:   0.000081
 Self time:   0.000081

count  total (s)   self (s)
   18              0.000075   return join([self.git_dir]+a:000,'/')

FUNCTION  remote#host#RegisterPlugin()
Called 1 time
Total time:   0.000074
 Self time:   0.000059

count  total (s)   self (s)
    1   0.000020   0.000012   let plugins = remote#host#PluginsForHost(a:host)
                            
    1              0.000002   for plugin in plugins
                                if plugin.path == a:path
                                  throw 'Plugin "'.a:path.'" is already registered'
                                endif
                              endfor
                            
    1   0.000015   0.000009   if has_key(s:hosts, a:host) && remote#host#IsRunning(a:host)
                                " For now we won't allow registration of plugins when the host is already
                                " running.
                                throw 'Host "'.a:host.'" is already running'
                              endif
                            
    1              0.000001   for spec in a:specs
                                let type = spec.type
                                let name = spec.name
                                let sync = spec.sync
                                let opts = spec.opts
                                let rpc_method = a:path
                                if type == 'command'
                                  let rpc_method .= ':command:'.name
                                  call remote#define#CommandOnHost(a:host, rpc_method, sync, name, opts)
                                elseif type == 'autocmd'
                                  " Since multiple handlers can be attached to the same autocmd event by a
                                  " single plugin, we need a way to uniquely identify the rpc method to
                                  " call.  The solution is to append the autocmd pattern to the method
                                  " name(This still has a limit: one handler per event/pattern combo, but
                                  " there's no need to allow plugins define multiple handlers in that case)
                                  let rpc_method .= ':autocmd:'.name.':'.get(opts, 'pattern', '*')
                                  call remote#define#AutocmdOnHost(a:host, rpc_method, sync, name, opts)
                                elseif type == 'function'
                                  let rpc_method .= ':function:'.name
                                  call remote#define#FunctionOnHost(a:host, rpc_method, sync, name, opts)
                                else
                                  echoerr 'Invalid declaration type: '.type
                                endif
                              endfor
                            
    1              0.000004   call add(plugins, {'path': a:path, 'specs': a:specs})

FUNCTION  <SNR>11_LoadFTPlugin()
Called 3 times
Total time:   0.007806
 Self time:   0.007125

count  total (s)   self (s)
    3              0.000011     if exists("b:undo_ftplugin")
                                  exe b:undo_ftplugin
                                  unlet! b:undo_ftplugin b:did_ftplugin
                                endif
                            
    3              0.000011     let s = expand("<amatch>")
    3              0.000005     if s != ""
    3              0.000020       if &cpo =~# "S" && exists("b:did_ftplugin")
                            	" In compatible mode options are reset to the global values, need to
                            	" set the local values also when a plugin was already used.
                            	unlet b:did_ftplugin
                                  endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "aaa" and then "bbb".
    6              0.000021       for name in split(s, '\.')
    3   0.007692   0.007011 	exe 'runtime! ftplugin/' . name . '.vim ftplugin/' . name . '_*.vim ftplugin/' . name . '/*.vim'
    3              0.000004       endfor
    3              0.000002     endif

FUNCTION  <SNR>88_win_init()
Called 2 times
Total time:   0.000043
 Self time:   0.000043

count  total (s)   self (s)
    2              0.000015   let w:dirvish = extend(get(w:, 'dirvish', {}), b:dirvish, 'keep')
    2              0.000009   setlocal nowrap cursorline
                            
    2              0.000004   if has('conceal')
    2              0.000010     setlocal concealcursor=nvc conceallevel=3
    2              0.000001   endif

FUNCTION  <SNR>88_should_reload()
Called 2 times
Total time:   0.000032
 Self time:   0.000025

count  total (s)   self (s)
    2              0.000008   if line('$') < 1000 || '' ==# glob(getline('$'),1)
    2   0.000023   0.000016     return !s:buf_modified() || (empty(getline(1)) && 1 == line('$'))
                              endif
                              redraw | echo 'dirvish: showing cached listing ("R" to reload)'
                              return 0

FUNCTION  <SNR>53_DisableShellSlash()
Called 1 time
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
                                " disable shellslash for proper escaping of Windows paths
                            
                                " In Windows, 'shellslash' also changes the behavior of 'shellescape'.
                                " It makes 'shellescape' behave like in UNIX environment. So ':setl
                                " noshellslash' before evaluating 'shellescape' and restore the
                                " settings afterwards when 'shell' does not contain 'sh' somewhere.
    1              0.000004     if has('win32') && empty(matchstr(&shell, 'sh'))
                                    let s:old_shellslash = &l:shellslash
                                    setlocal noshellslash
                                endif

FUNCTION  provider#python#Prog()
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000003   return s:prog

FUNCTION  fugitive#buffer()
Called 5 times
Total time:   0.000182
 Self time:   0.000028

count  total (s)   self (s)
    5   0.000180   0.000025   return s:buffer(a:0 ? a:1 : '%')

FUNCTION  provider#pythonx#Require()
Called 1 time
Total time:   0.599849
 Self time:   0.599533

count  total (s)   self (s)
    1              0.000003   let ver = (a:host.orig_name ==# 'python') ? 2 : 3
                            
                              " Python host arguments
    1   0.000011   0.000007   let prog = (ver == '2' ?  provider#python#Prog() : provider#python3#Prog())
    1              0.000003   let args = [prog, '-c', 'import sys; sys.path.remove(""); import neovim; neovim.start_host()']
                            
                              " Collect registered Python plugins into args
    1   0.000010   0.000004   let python_plugins = remote#host#PluginsForHost(a:host.name)
    2              0.000003   for plugin in python_plugins
    1              0.000003     call add(args, plugin.path)
    1              0.000002   endfor
                            
    1              0.000001   try
    1              0.002044     let channel_id = jobstart(args, s:job_opts)
    1              0.596859     if rpcrequest(channel_id, 'poll') ==# 'ok'
    1              0.000004       return channel_id
                                endif
                              catch
                                echomsg v:throwpoint
                                echomsg v:exception
                                for row in provider#get_stderr(channel_id)
                                  echomsg row
                                endfor
                              finally
    1   0.000884   0.000577     call provider#clear_stderr(channel_id)
    1              0.000003   endtry
                              throw remote#host#LoadErrorForHost(a:host.orig_name, '$NVIM_PYTHON_LOG_FILE')

FUNCTION  <SNR>60_define_commands()
Called 3 times
Total time:   0.000694
 Self time:   0.000694

count  total (s)   self (s)
   84              0.000087   for command in s:commands
   81              0.000527     exe 'command! -buffer '.command
   81              0.000059   endfor

FUNCTION  <SNR>60_buffer_repo()
Called 12 times
Total time:   0.000380
 Self time:   0.000080

count  total (s)   self (s)
   12   0.000376   0.000076   return s:repo(self.getvar('git_dir'))

FUNCTION  <SNR>53_ApplyConfig()
Called 1 time
Total time:   0.000908
 Self time:   0.000622

count  total (s)   self (s)
                                " Only process normal buffers (do not treat help files as '.txt' files)
    1              0.000005     if !empty(&buftype)
                                    return
                                endif
                            
                            " Set the indentation style according to the config values
                            
    1   0.000020   0.000013     if s:IsRuleActive('indent_style', a:config)
    1              0.000003         if a:config["indent_style"] == "tab"
                                        setl noexpandtab
                                    elseif a:config["indent_style"] == "space"
    1              0.000012             setl expandtab
    1              0.000001         endif
    1              0.000001     endif
    1   0.000009   0.000004     if s:IsRuleActive('tab_width', a:config)
    1              0.000011         let &l:tabstop = str2nr(a:config["tab_width"])
    1              0.000001     endif
    1   0.000008   0.000004     if s:IsRuleActive('indent_size', a:config)
                                    " if indent_size is 'tab', set shiftwidth to tabstop;
                                    " if indent_size is a positive integer, set shiftwidth to the integer
                                    " value
    1              0.000002         if a:config["indent_size"] == "tab"
                                        let &l:shiftwidth = &l:tabstop
                                        let &l:softtabstop = &l:shiftwidth
                                    else
    1              0.000004             let l:indent_size = str2nr(a:config["indent_size"])
    1              0.000001             if l:indent_size > 0
    1              0.000008                 let &l:shiftwidth = l:indent_size
    1              0.000004                 let &l:softtabstop = &l:shiftwidth
    1              0.000001             endif
    1              0.000001         endif
                            
    1              0.000001     endif
                            
    1   0.000008   0.000004     if s:IsRuleActive('end_of_line', a:config) && &l:modifiable
                                    if a:config["end_of_line"] == "lf"
                                        setl fileformat=unix
                                    elseif a:config["end_of_line"] == "crlf"
                                        setl fileformat=dos
                                    elseif a:config["end_of_line"] == "cr"
                                        setl fileformat=mac
                                    endif
                                endif
                            
    1   0.000007   0.000003     if s:IsRuleActive('charset', a:config) && &l:modifiable
                                    if a:config["charset"] == "utf-8"
                                        setl fileencoding=utf-8
                                        setl nobomb
                                    elseif a:config["charset"] == "utf-8-bom"
                                        setl fileencoding=utf-8
                                        setl bomb
                                    elseif a:config["charset"] == "latin1"
                                        setl fileencoding=latin1
                                        setl nobomb
                                    elseif a:config["charset"] == "utf-16be"
                                        setl fileencoding=utf-16be
                                        setl bomb
                                    elseif a:config["charset"] == "utf-16le"
                                        setl fileencoding=utf-16le
                                        setl bomb
                                    endif
                                endif
                            
    1              0.000003     augroup editorconfig_trim_trailing_whitespace
    1              0.000004         autocmd! BufWritePre <buffer>
    1   0.000010   0.000005         if s:IsRuleActive('trim_trailing_whitespace', a:config) && get(a:config, 'trim_trailing_whitespace', 'false') ==# 'true'
                                        autocmd BufWritePre <buffer> call s:TrimTrailingWhitespace()
                                    endif
    1              0.000001     augroup END
                            
    1   0.000007   0.000003     if s:IsRuleActive('insert_final_newline', a:config)
                                    if exists('+fixendofline')
                                        if a:config["insert_final_newline"] == "false"
                                            setl nofixendofline
                                        else
                                            setl fixendofline
                                        endif
                                    elseif  exists(':SetNoEOL') == 2
                                        if a:config["insert_final_newline"] == "false"
                                            silent! SetNoEOL    " Use the PreserveNoEOL plugin to accomplish it
                                        endif
                                    endif
                                endif
                            
                                " highlight the columns following max_line_length
    1   0.000008   0.000004     if s:IsRuleActive('max_line_length', a:config) && a:config['max_line_length'] != 'off'
                                    let l:max_line_length = str2nr(a:config['max_line_length'])
                            
                                    if l:max_line_length >= 0
                                        let &l:textwidth = l:max_line_length
                                        if g:EditorConfig_preserve_formatoptions == 0
                                            setlocal formatoptions+=tc
                                        endif
                                    endif
                            
                                    if exists('+colorcolumn')
                                        if l:max_line_length > 0
                                            if g:EditorConfig_max_line_indicator == 'line'
                                                let &l:colorcolumn = l:max_line_length + 1
                                            elseif g:EditorConfig_max_line_indicator == 'fill' && l:max_line_length < &l:columns
                                                " Fill only if the columns of screen is large enough
                                                let &l:colorcolumn = join( range(l:max_line_length+1,&l:columns),',')
                                            elseif g:EditorConfig_max_line_indicator == 'exceeding'
                                                let &l:colorcolumn = ''
                                                for l:match in getmatches()
                                                    if get(l:match, 'group', '') == 'ColorColumn'
                                                        call matchdelete(get(l:match, 'id'))
                                                    endif
                                                endfor
                                                call matchadd('ColorColumn', '\%' . (l:max_line_length + 1) . 'v', 100)
                                            endif
                                        endif
                                    endif
                                endif
                            
    1   0.000671   0.000422     call editorconfig#ApplyHooks(a:config)

FUNCTION  <SNR>60_cpath()
Called 9 times
Total time:   0.000051
 Self time:   0.000051

count  total (s)   self (s)
    9              0.000024   if exists('+fileignorecase') && &fileignorecase
    9              0.000021     return tolower(a:path)
                              else
                                return a:path
                              endif

FUNCTION  <SNR>98_check_interpreter()
Called 1 time
Total time:   0.487010
 Self time:   0.487010

count  total (s)   self (s)
    1              0.000075   let prog_path = exepath(a:prog)
    1              0.000002   if prog_path ==# ''
                                return [0, a:prog . ' not found in search path or not executable.']
                              endif
                            
    1              0.000003   let min_version = (a:major_ver == 2) ? '2.6' : '3.3'
                            
                              " Try to load neovim module, and output Python version.
                              " Return codes:
                              "   0  Neovim module can be loaded.
                              "   2  Neovim module cannot be loaded.
                              "   Otherwise something else went wrong (e.g. 1 or 127).
    1              0.486852   let prog_ver = system([ a:prog , '-c' , 'import sys; ' . 'sys.path.remove(""); ' . 'sys.stdout.write(str(sys.version_info[0]) + "." + str(sys.version_info[1])); ' . 'import pkgutil; ' . 'exit(2*int(pkgutil.get_loader("neovim") is None))' ])
                            
    1              0.000006   if v:shell_error == 2 || v:shell_error == 0
                                " Check version only for expected return codes.
    1              0.000035     if prog_ver !~ '^' . a:major_ver
                                  return [0, prog_path . ' is Python ' . prog_ver . ' and cannot provide Python ' . a:major_ver . '.']
                                elseif prog_ver =~ '^' . a:major_ver && prog_ver < min_version
                                  return [0, prog_path . ' is Python ' . prog_ver . ' and cannot provide Python >= ' . min_version . '.']
                                endif
    1              0.000000   endif
                            
    1              0.000001   if v:shell_error == 2
                                return [0, prog_path.' does not have the "neovim" module. :help provider-python']
                              elseif v:shell_error == 127
                                " This can happen with pyenv's shims.
                                return [0, prog_path . ' does not exist: ' . prog_ver]
                              elseif v:shell_error
                                return [0, 'Checking ' . prog_path . ' caused an unknown error. ' . '(' . v:shell_error . ', output: ' . prog_ver . ')' . ' Report this at https://github.com/neovim/neovim']
                              endif
                            
    1              0.000003   return [1, '']

FUNCTION  AutoSaveWinView()
Called 1 time
Total time:   0.000021
 Self time:   0.000021

count  total (s)   self (s)
    1              0.000006   if !exists("w:SavedBufView")
    1              0.000003     let w:SavedBufView = {}
    1              0.000001   endif
    1              0.000009   let w:SavedBufView[bufnr("%")] = winsaveview()

FUNCTION  <SNR>60_buffer_path()
Called 2 times
Total time:   0.001231
 Self time:   0.000189

count  total (s)   self (s)
    2   0.000114   0.000025   let rev = matchstr(self.spec(),'^fugitive://.\{-\}//\zs.*')
    2              0.000002   if rev != ''
                                let rev = s:sub(rev,'\w*','')
                              elseif s:cpath(self.spec()[0 : len(self.repo().dir())]) ==# s:cpath(self.repo().dir() . '/')
                                let rev = '/.git'.self.spec()[strlen(self.repo().dir()) : -1]
                              elseif !self.repo().bare() && s:cpath(self.spec()[0 : len(self.repo().tree())]) ==# s:cpath(self.repo().tree() . '/')
    2   0.000223   0.000019     let rev = self.spec()[strlen(self.repo().tree()) : -1]
    2              0.000001   endif
    2   0.000050   0.000017   return s:sub(s:sub(rev,'.\zs/$',''),'^/',a:0 ? a:1 : '')

FUNCTION  <SNR>88_buf_render()
Called 2 times
Total time:   0.002593
 Self time:   0.000278

count  total (s)   self (s)
    2              0.000005   let bname = bufname('%')
    2              0.000007   let isnew = empty(getline(1))
                            
    2   0.000047   0.000040   if !isdirectory(s:sl(bname))
                                echoerr 'dirvish: fatal: buffer name is not a directory:' bufname('%')
                                return
                              endif
                            
    2              0.000002   if !isnew
    1   0.000115   0.000008     call s:bufwin_do('let w:dirvish["_view"] = winsaveview()', bname)
    1              0.000000   endif
                            
    2              0.000005   if v:version > 704 || v:version == 704 && has("patch73")
    2              0.000007     setlocal undolevels=-1
    2              0.000001   endif
    2              0.000035   silent keepmarks keepjumps %delete _
    2   0.002153   0.000048   silent keepmarks keepjumps call setline(1, s:list_dir(a:dir))
    2              0.000009   if type("") == type(get(g:, 'dirvish_mode'))  " Apply user's filter.
                                execute get(g:, 'dirvish_mode')
                              endif
    2              0.000004   if v:version > 704 || v:version == 704 && has("patch73")
    2              0.000009     setlocal undolevels<
    2              0.000001   endif
                            
    2              0.000002   if !isnew
    1   0.000101   0.000006     call s:bufwin_do('call winrestview(w:dirvish["_view"])', bname)
    1              0.000000   endif
                            
    2              0.000004   if !empty(a:lastpath)
                                let pat = get(g:, 'dirvish_relative_paths', 0) ? fnamemodify(a:lastpath, ':p:.') : a:lastpath
                                let pat = empty(pat) ? a:lastpath : pat  " no longer in CWD
                                call search('\V\^'.escape(pat, '\').'\$', 'cw')
                              endif
                              " Place cursor on the tail (last path segment).
    2              0.000042   call search('\'.s:sep.'\zs[^\'.s:sep.']\+\'.s:sep.'\?$', 'c', line('.'))

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
    3   1.152257   0.000185  dirvish#open()
    1   1.126939   0.004908  <SNR>88_open_selected()
    1   1.105677   0.000161  <SNR>53_UseConfigFiles()
    1   1.102557   0.000132  <SNR>53_Initialize()
    1   1.100826   0.612652  <SNR>53_InitializePythonBuiltin()
    2   0.614059   0.014168  provider#python#Call()
    1   0.599890   0.000041  remote#host#Require()
    1   0.599849   0.599533  provider#pythonx#Require()
    1   0.487068   0.000058  provider#pythonx#Detect()
    1   0.487010             <SNR>98_check_interpreter()
    2   0.024237   0.000328  <SNR>88_open_dir()
    3   0.010472   0.002834  <SNR>14_SynSet()
    3   0.007806   0.007125  <SNR>11_LoadFTPlugin()
    3   0.004870   0.000809  fugitive#detect()
    1   0.002909   0.002001  <SNR>53_UseConfigFiles_Python_Builtin()
    2   0.002593   0.000278  <SNR>88_buf_render()
    2   0.002105   0.000499  <SNR>88_list_dir()
    4   0.001606   0.001579  <SNR>88_globlist()
    1   0.001599   0.001583  <SNR>53_FindPythonFiles()
    3   0.001547   0.001323  <SNR>12_LoadIndent()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
    1   1.100826   0.612652  <SNR>53_InitializePythonBuiltin()
    1   0.599849   0.599533  provider#pythonx#Require()
    1              0.487010  <SNR>98_check_interpreter()
    2   0.614059   0.014168  provider#python#Call()
    3   0.007806   0.007125  <SNR>11_LoadFTPlugin()
    1   1.126939   0.004908  <SNR>88_open_selected()
    3   0.010472   0.002834  <SNR>14_SynSet()
    1   0.002909   0.002001  <SNR>53_UseConfigFiles_Python_Builtin()
    1   0.001599   0.001583  <SNR>53_FindPythonFiles()
    4   0.001606   0.001579  <SNR>88_globlist()
    3   0.001547   0.001323  <SNR>12_LoadIndent()
    3   0.004870   0.000809  fugitive#detect()
    3              0.000694  <SNR>60_define_commands()
    1   0.000908   0.000622  <SNR>53_ApplyConfig()
    2   0.002105   0.000499  <SNR>88_list_dir()
   18   0.000705   0.000445  <SNR>60_buffer_spec()
    5              0.000444  <SNR>73_Highlight_Matching_Pair()
    2   0.000771   0.000419  fugitive#extract_git_dir()
    2   0.024237   0.000328  <SNR>88_open_dir()
    3   0.000614   0.000305  <SNR>60_buffer_type()

